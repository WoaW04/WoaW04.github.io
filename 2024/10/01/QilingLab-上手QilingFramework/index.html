<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>QilingLab-上手QilingFramework | The Blog of WoaW04</title><meta name="author" content="WoaW04"><meta name="copyright" content="WoaW04"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="0x00 前言第一次接触模拟执行这个东西，从QilingFramework开始上手试试看，后面还要学Qemu、Unicorn、Unidbg等 0x01 解使用 1git clone https:&#x2F;&#x2F;github.com&#x2F;qilingframework&#x2F;qiling.git --recursiv  克隆整个仓库 由于x86_64和aarch64题目内容，而我使用的是x86_64平台，因此为了体现模拟">
<meta property="og:type" content="article">
<meta property="og:title" content="QilingLab-上手QilingFramework">
<meta property="og:url" content="https://woaw04.github.io/2024/10/01/QilingLab-%E4%B8%8A%E6%89%8BQilingFramework/index.html">
<meta property="og:site_name" content="The Blog of WoaW04">
<meta property="og:description" content="0x00 前言第一次接触模拟执行这个东西，从QilingFramework开始上手试试看，后面还要学Qemu、Unicorn、Unidbg等 0x01 解使用 1git clone https:&#x2F;&#x2F;github.com&#x2F;qilingframework&#x2F;qiling.git --recursiv  克隆整个仓库 由于x86_64和aarch64题目内容，而我使用的是x86_64平台，因此为了体现模拟">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/WoaW04/Picture/main/202410010015849.png">
<meta property="article:published_time" content="2024-09-30T16:13:19.000Z">
<meta property="article:modified_time" content="2024-10-01T14:11:43.668Z">
<meta property="article:author" content="WoaW04">
<meta property="article:tag" content="RE">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/WoaW04/Picture/main/202410010015849.png"><link rel="shortcut icon" href="https://raw.githubusercontent.com/WoaW04/Picture/main/202503031814307.jpg"><link rel="canonical" href="https://woaw04.github.io/2024/10/01/QilingLab-%E4%B8%8A%E6%89%8BQilingFramework/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: false,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'QilingLab-上手QilingFramework',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-01 22:11:43'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://raw.githubusercontent.com/WoaW04/Picture/main/202503031814307.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">61</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://raw.githubusercontent.com/WoaW04/Picture/main/202410010015849.png')"><nav id="nav"><span id="blog-info"><a href="/" title="The Blog of WoaW04"><img class="site-icon" src="https://raw.githubusercontent.com/WoaW04/Picture/main/202503031814307.jpg"/><span class="site-name">The Blog of WoaW04</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">QilingLab-上手QilingFramework</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-09-30T16:13:19.000Z" title="发表于 2024-10-01 00:13:19">2024-10-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-01T14:11:43.668Z" title="更新于 2024-10-01 22:11:43">2024-10-01</time></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>第一次接触模拟执行这个东西，从QilingFramework开始上手试试看，后面还要学Qemu、Unicorn、Unidbg等</p>
<h2 id="0x01-解"><a href="#0x01-解" class="headerlink" title="0x01 解"></a>0x01 解</h2><p>使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/qilingframework/qiling.git --recursiv</span><br></pre></td></tr></table></figure>

<p>克隆整个仓库</p>
<p>由于<code>x86_64</code>和<code>aarch64</code>题目内容，而我使用的是<code>x86_64</code>平台，因此为了体现模拟执行的强大，以下都使用<code>aarch64</code>的文件来解</p>
<p>之后使用模板如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 模板如下：</span></span><br><span class="line"><span class="keyword">from</span> qiling <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> qiling.const <span class="keyword">import</span> QL_VERBOSE</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge1</span>(<span class="params">ql: Qiling</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__  == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    path = [<span class="string">&#x27;qilinglab/qilinglab-aarch64&#x27;</span>] <span class="comment"># lab目标</span></span><br><span class="line">    rootfs = <span class="string">&quot;./examples/rootfs/arm64_linux&quot;</span> <span class="comment"># 在clone下来的仓库里</span></span><br><span class="line">    ql = Qiling(path, rootfs,verbose=QL_VERBOSE.OFF) <span class="comment"># 关闭了VERBOSE，否则输出太难看了</span></span><br><span class="line">    challenge1(ql) <span class="comment"># 在ql.run()之前，做好hook工作</span></span><br><span class="line">    ql.run()</span><br></pre></td></tr></table></figure>

<h3 id="Challenge-1-Store-1337-at-pointer-0x1337"><a href="#Challenge-1-Store-1337-at-pointer-0x1337" class="headerlink" title="Challenge 1: Store 1337 at pointer 0x1337."></a>Challenge 1: Store 1337 at pointer 0x1337.</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_BYTE *__fastcall <span class="title function_">challenge1</span><span class="params">(_BYTE *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE *result; <span class="comment">// x0</span></span><br><span class="line"></span><br><span class="line">  result = (_BYTE *)*(<span class="type">unsigned</span> <span class="type">int</span> *)((<span class="type">char</span> *)&amp;loc_1334 + <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">if</span> ( *(_DWORD *)((<span class="type">char</span> *)&amp;loc_1334 + <span class="number">3</span>) == <span class="number">1337</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = a1;</span><br><span class="line">    *a1 = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将值<code>1337</code>放入地址<code>0x1337</code>中，然而实际上并不能保证程序加载基地址，这里需要用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ql.mem.<span class="built_in">map</span>(<span class="number">0x1000</span>, <span class="number">0x1000</span>, info=<span class="string">&#x27;[challenge]&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://docs.qiling.io/en/latest/memory/#:~:text=Mapping%20memory%20pages">映射一块内存</a>，需要注意的是，Qiling底层就是用的Unicorn Engine，内存映射时，<a target="_blank" rel="noopener" href="https://github.com/unicorn-engine/unicorn/blob/d568885d64c89db5b9a722f0c1bef05aa92f84ca/include/unicorn/unicorn.h#L1033">要4k对齐</a>。</p>
<p>之后向里面<a target="_blank" rel="noopener" href="https://docs.qiling.io/en/latest/memory/#:~:text=Write%20to%20a%20memory%20address">写内容</a>就可以了，注意写的时候内容要进行<a target="_blank" rel="noopener" href="https://docs.qiling.io/en/latest/struct/#:~:text=Size%3A%204%20bytes-,ql.pack16(),-pack%20for%2016bit">打包</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">challenge1</span>(<span class="params">ql: Qiling</span>):</span><br><span class="line">    ql.mem.<span class="built_in">map</span>(<span class="number">0x1000</span>,<span class="number">0x1000</span>)</span><br><span class="line">    ql.mem.write(<span class="number">0x1337</span>,ql.pack16(<span class="number">1337</span>))</span><br></pre></td></tr></table></figure>

<p>这就能过第一个了</p>
<h3 id="Challenge-2-Make-the-‘uname’-syscall-return-the-correct-values"><a href="#Challenge-2-Make-the-‘uname’-syscall-return-the-correct-values" class="headerlink" title="Challenge 2: Make the ‘uname’ syscall return the correct values."></a>Challenge 2: Make the ‘uname’ syscall return the correct values.</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">challenge2</span><span class="params">(_BYTE *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v3; <span class="comment">// [xsp+30h] [xbp+30h]</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [xsp+34h] [xbp+34h]</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [xsp+38h] [xbp+38h]</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [xsp+3Ch] [xbp+3Ch]</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">utsname</span> <span class="title">name</span>;</span> <span class="comment">// [xsp+40h] [xbp+40h] BYREF</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">16</span>]; <span class="comment">// [xsp+1C8h] [xbp+1C8h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v9[<span class="number">16</span>]; <span class="comment">// [xsp+1D8h] [xbp+1D8h] BYREF</span></span><br><span class="line">  __int64 v10; <span class="comment">// [xsp+1E8h] [xbp+1E8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( uname(&amp;name) )</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;uname&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(s, <span class="string">&quot;QilingOS&quot;</span>);</span><br><span class="line">    s[<span class="number">9</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(v9, <span class="string">&quot;ChallengeStart&quot;</span>);</span><br><span class="line">    v9[<span class="number">15</span>] = <span class="number">0</span>;</span><br><span class="line">    v3 = <span class="number">0</span>;</span><br><span class="line">    v4 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( v5 &lt; <span class="built_in">strlen</span>(s) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( name.sysname[v5] == s[v5] )</span><br><span class="line">        ++v3;</span><br><span class="line">      ++v5;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( v6 &lt; <span class="built_in">strlen</span>(v9) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( name.version[v6] == v9[v6] )</span><br><span class="line">        ++v4;</span><br><span class="line">      ++v6;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v3 == <span class="built_in">strlen</span>(s) &amp;&amp; v4 == <span class="built_in">strlen</span>(v9) &amp;&amp; v3 &gt; <span class="number">5</span> )</span><br><span class="line">      *a1 = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v10 ^ _stack_chk_guard;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这边是需要让<code>uname</code>这个<code>syscall</code>返回的内容与设置的相同，设置的值为<code>sysname==QilingOS</code>且<code>version==ChallengeStart</code></p>
<p><code>uname</code>这个函数传入一个<code>utsname</code>的结构体的地址，填充后返回</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/utsname.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _UTSNAME_SYSNAME_LENGTH 65</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">utsname</span>&#123;</span> </span><br><span class="line">    <span class="type">char</span> sysname[_UTSNAME_SYSNAME_LENGTH];<span class="comment">//当前操作系统名</span></span><br><span class="line">    <span class="type">char</span> nodename[_UTSNAME_NODENAME_LENGTH];<span class="comment">//网络上的名称</span></span><br><span class="line">    <span class="type">char</span> release[_UTSNAME_RELEASE_LENGTH];<span class="comment">//当前发布级别</span></span><br><span class="line">    <span class="type">char</span> version[_UTSNAME_VERSION_LENGTH];<span class="comment">//当前发布版本</span></span><br><span class="line">    <span class="type">char</span> machine[_UTSNAME_MACHINE_LENGTH];<span class="comment">//当前硬件体系类型</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _UTSNAME_DOMAIN_LENGTH - 0</span></span><br><span class="line">    <span class="comment">/* Name of the domain of this node on the network.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> __USE_GNU</span></span><br><span class="line">    <span class="type">char</span> domainname[_UTSNAME_DOMAIN_LENGTH]; <span class="comment">//当前域名</span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">    <span class="type">char</span> __domainname[_UTSNAME_DOMAIN_LENGTH];</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Qiling提供了在系统调用返回时进行<code>hook</code>的<a target="_blank" rel="noopener" href="https://docs.qiling.io/en/latest/hijack/#hijacking-posix-system-calls:~:text=Hijacking%20POSIX%20system%20calls">功能</a>。</p>
<p>首先需要知道返回值被存储在了哪个寄存器（因为这是<code>ARM64</code>，所以跟<code>X64</code>不一样）</p>
<p>根据汇编</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">name= -0x1B0</span><br><span class="line">...</span><br><span class="line">ADD             X0, SP, #0x1F0+name ; add r2, r1, #2 (r2 = r1 + 2)</span><br><span class="line">BL              .uname</span><br></pre></td></tr></table></figure>

<p>可以知道返回值由<code>SP</code>和<code>0x1F0+name</code>的值相加得到，被存在了<code>X0</code>寄存器，所以劫持地址为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x0 = ql.arch.regs.sp + <span class="number">0x1F0</span> - <span class="number">0x1B0</span></span><br></pre></td></tr></table></figure>

<p>之后就是写内容，注意要按照结构体的顺序来写，<code>sysname</code>和<code>version</code>中间的<code>nodename</code>和<code>release</code>要跳过不去动</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hook_uname_func</span>(<span class="params">ql: Qiling,*args</span>):</span><br><span class="line">    x0 = ql.arch.regs.sp + <span class="number">0x1F0</span> - <span class="number">0x1B0</span></span><br><span class="line">    ql.mem.write(x0,<span class="string">b&#x27;QilingOS\x00&#x27;</span>)</span><br><span class="line">    ql.mem.write(x0+<span class="number">65</span>*<span class="number">3</span>,<span class="string">b&#x27;ChallengeStart\x00&#x27;</span>) <span class="comment"># (x0+65*3）跳过nodename和release</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge2</span>(<span class="params">ql: Qiling</span>):</span><br><span class="line">    ql.os.set_syscall(<span class="string">&quot;uname&quot;</span>, hook_uname_func, QL_INTERCEPT.EXIT) <span class="comment"># 函数返回时进行hook</span></span><br></pre></td></tr></table></figure>

<h3 id="Challenge-3-Make-‘-dev-urandom’-and-‘getrandom’-“collide”"><a href="#Challenge-3-Make-‘-dev-urandom’-and-‘getrandom’-“collide”" class="headerlink" title="Challenge 3: Make ‘&#x2F;dev&#x2F;urandom’ and ‘getrandom’ “collide”."></a>Challenge 3: Make ‘&#x2F;dev&#x2F;urandom’ and ‘getrandom’ “collide”.</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">challenge3</span><span class="params">(_BYTE *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [xsp+24h] [xbp+24h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [xsp+28h] [xbp+28h]</span></span><br><span class="line">  <span class="type">int</span> fd; <span class="comment">// [xsp+2Ch] [xbp+2Ch]</span></span><br><span class="line">  <span class="type">char</span> v6[<span class="number">8</span>]; <span class="comment">// [xsp+30h] [xbp+30h] BYREF</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">32</span>]; <span class="comment">// [xsp+38h] [xbp+38h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v8[<span class="number">32</span>]; <span class="comment">// [xsp+58h] [xbp+58h] BYREF</span></span><br><span class="line">  __int64 v9; <span class="comment">// [xsp+78h] [xbp+78h]</span></span><br><span class="line"></span><br><span class="line">  fd = open(<span class="string">&quot;/dev/urandom&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  read(fd, buf, <span class="number">0x20</span>uLL);</span><br><span class="line">  read(fd, v6, <span class="number">1uLL</span>);</span><br><span class="line">  close(fd);</span><br><span class="line">  getrandom(v8, <span class="number">32LL</span>, <span class="number">1LL</span>);</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">31</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( buf[i] == v8[i] &amp;&amp; buf[i] != v6[<span class="number">0</span>] )</span><br><span class="line">      ++v3;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v3 == <span class="number">32</span> )</span><br><span class="line">    *a1 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> v9 ^ _stack_chk_guard;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>挑战三需要让<code>open</code>函数中获取的值与<code>getrandom</code>函数中的值一致，且<code>/dev/urandom</code>中的最后一个值需要与<code>getrandom</code>中的任意一个值不同</p>
<p>要同时实现两个需求，需要更改<code>getrandom</code>函数的返回值和文件的内容</p>
<p>首先使用<code>ql.os.set_syscall</code>来劫持<code>getrandom</code>函数，与上一个挑战不同，这次用到的<code>ql.os.set_syscall</code>最后传入的参数是<code>QL_INTERCEPT.CALL</code>，即在函数被调用时进行劫持，运行指定的函数而不运行原先的函数，这时，由于参数会相应地进行传入，因此要确保接受参数一致（有默认值除外）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hook_getrandom_func</span>(<span class="params">ql: Qiling,buf,buflen</span>):</span><br><span class="line">    ql.mem.write(buf,<span class="string">b&#x27;\x00&#x27;</span>*buflen)</span><br><span class="line">    ql.os.set_syscall_return(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>之后要保证<code>/dev/urandom</code>内容一致，使用到<a target="_blank" rel="noopener" href="https://docs.qiling.io/en/latest/hijack/#:~:text=Hijacking%20VFS%20objects">自定义文件系统</a>的功能，先定义一个<code>FakeUrandom</code>类，然后将内容填入<code>read</code>函数中，完成对<code>read</code>函数的重定向（<code>close</code>函数默认就行，<code>fstat</code>函数可以不要，注意读取单字节时要与读取多字节不同）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FakeUrandom</span>(<span class="title class_ inherited__">QlFsMappedObject</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">self, size: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bytes</span>:</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">b&#x27;\xE9&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&quot;\x00&quot;</span>*size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>最终整合如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FakeUrandom</span>(<span class="title class_ inherited__">QlFsMappedObject</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">self, size: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bytes</span>:</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">b&#x27;\xE9&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&quot;\x00&quot;</span>*size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hook_getrandom_func</span>(<span class="params">ql: Qiling,buf,buflen</span>):</span><br><span class="line">    ql.mem.write(buf,<span class="string">b&#x27;\x00&#x27;</span>*buflen)</span><br><span class="line">    ql.os.set_syscall_return(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge3</span>(<span class="params">ql: Qiling</span>):</span><br><span class="line">    ql.os.set_syscall(<span class="string">&quot;getrandom&quot;</span>, hook_getrandom_func)</span><br><span class="line">    ql.add_fs_mapper(<span class="string">&quot;/dev/urandom&quot;</span>, FakeUrandom())</span><br></pre></td></tr></table></figure>

<h3 id="Challenge-4-Enter-inside-the-“forbidden”-loop"><a href="#Challenge-4-Enter-inside-the-“forbidden”-loop" class="headerlink" title="Challenge 4: Enter inside the “forbidden” loop."></a>Challenge 4: Enter inside the “forbidden” loop.</h3><p>这个函数IDA无法解析，只剩下一个<code>return 0</code></p>
<p>手动逆一下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">challenge4</span><span class="params">(_BYTE *v15)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        *v15 = <span class="number">1</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>搞了一个进不去的循环，然后在里面进行判断变量的赋值，因此要进这个函数需要通过<code>hook</code>来改变寄存器内容进入这个函数，Qiling是有提供这个<a target="_blank" rel="noopener" href="https://docs.qiling.io/en/latest/hook/">功能</a>的</p>
<p>这边需要<code>hook</code>跳转前的位置，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hook_FE4</span>(<span class="params">ql: Qiling</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    .text:0000000000000FE0 3F 00 00 6B                   CMP             W1, W0</span></span><br><span class="line"><span class="string">    .text:0000000000000FE4 EB FE FF 54                   B.LT            loc_FC0</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    ql.arch.regs.W0 = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge4</span>(<span class="params">ql: Qiling</span>):</span><br><span class="line">    <span class="comment"># 根据文件路径查找已经加载的文件，获取对应文件的基地址</span></span><br><span class="line">    <span class="comment"># os.path.split(ql.path)：os.path.split 函数将 ql.path 分成两部分：目录名和基本文件名。这个函数返回一个包含这两部分的元组。</span></span><br><span class="line">    <span class="comment"># os.path.split(ql.path)[-1]：这将返回元组中的最后一个元素，即基本文件名。在 Python 中，-1 索引表示列表或元组的最后一个元素。</span></span><br><span class="line">    <span class="comment"># base = ql.mem.get_lib_base(os.path.split(ql.path)[-1])：ql.mem.get_lib_base 函数使用提取的文件名作为参数，以获取已加载库的基地址。将返回的基地址赋值给变量 base</span></span><br><span class="line">    base_addr = ql.mem.get_lib_base(os.path.split(ql.path)[-<span class="number">1</span>]) <span class="comment"># 需要先搞到基地址</span></span><br><span class="line">    enter_loop = base_addr + <span class="number">0xfe0</span> <span class="comment"># 基地址+偏移</span></span><br><span class="line">    ql.hook_address(hook_FE4,enter_loop)</span><br></pre></td></tr></table></figure>

<h3 id="Challenge-5-Guess-every-call-to-rand"><a href="#Challenge-5-Guess-every-call-to-rand" class="headerlink" title="Challenge 5: Guess every call to rand()."></a>Challenge 5: Guess every call to rand().</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">challenge5</span><span class="params">(_BYTE *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v1; <span class="comment">// w0</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [xsp+20h] [xbp+20h]</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [xsp+24h] [xbp+24h]</span></span><br><span class="line">  _DWORD v6[<span class="number">12</span>]; <span class="comment">// [xsp+28h] [xbp+28h]</span></span><br><span class="line">  __int64 v7; <span class="comment">// [xsp+58h] [xbp+58h]</span></span><br><span class="line"></span><br><span class="line">  v1 = time(<span class="number">0LL</span>);</span><br><span class="line">  srand(v1);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v6[i] = <span class="number">0</span>;</span><br><span class="line">    v6[i + <span class="number">6</span>] = rand();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">4</span>; ++j )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v6[j] != v6[j + <span class="number">6</span>] )</span><br><span class="line">    &#123;</span><br><span class="line">      *a1 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> v7 ^ _stack_chk_guard;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  *a1 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> v7 ^ _stack_chk_guard;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这边直接<code>hook</code>函数<code>rand()</code>，让其一直返回<code>0</code>即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hook_rand_func</span>(<span class="params">ql: Qiling</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    返回值存在w0中</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    ql.arch.regs.W0=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge5</span>(<span class="params">ql:Qiling</span>):</span><br><span class="line">    ql.os.set_api(<span class="string">&#x27;rand&#x27;</span>,hook_rand_func, QL_INTERCEPT.CALL) <span class="comment"># 不同于syscall，库函数要用set_api</span></span><br></pre></td></tr></table></figure>

<p>由于challenge6卡死循环，所以没解决之前challenge5的内容不显示</p>
<h3 id="Challenge-6-Avoid-the-infinite-loop"><a href="#Challenge-6-Avoid-the-infinite-loop" class="headerlink" title="Challenge 6: Avoid the infinite loop."></a>Challenge 6: Avoid the infinite loop.</h3><p>进去就是一个死循环，只能靠看汇编解决</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000000010F0                               ; =============== S U B R O U T I N E =======================================</span><br><span class="line">.text:00000000000010F0</span><br><span class="line">.text:00000000000010F0</span><br><span class="line">.text:00000000000010F0                               ; void challenge6()</span><br><span class="line">.text:00000000000010F0                               EXPORT challenge6</span><br><span class="line">.text:00000000000010F0                               challenge6                              ; CODE XREF: start+1C0↓p</span><br><span class="line">.text:00000000000010F0</span><br><span class="line">.text:00000000000010F0                               var_18= -0x18</span><br><span class="line">.text:00000000000010F0                               var_5= -5</span><br><span class="line">.text:00000000000010F0                               var_4= -4</span><br><span class="line">.text:00000000000010F0</span><br><span class="line">.text:00000000000010F0                               ; __unwind &#123;</span><br><span class="line">.text:00000000000010F0 FF 83 00 D1                   SUB             SP, SP, #0x20</span><br><span class="line">.text:00000000000010F4 E0 07 00 F9                   STR             X0, [SP,#0x20+var_18]</span><br><span class="line">.text:00000000000010F8 FF 1F 00 B9                   STR             WZR, [SP,#0x20+var_4]</span><br><span class="line">.text:00000000000010FC 20 00 80 52                   MOV             W0, #1</span><br><span class="line">.text:0000000000001100 E0 6F 00 39                   STRB            W0, [SP,#0x20+var_5]</span><br><span class="line">.text:0000000000001104 03 00 00 14                   B               loc_1110</span><br><span class="line">.text:0000000000001104</span><br><span class="line">.text:0000000000001108                               ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000001108</span><br><span class="line">.text:0000000000001108                               loc_1108                                ; CODE XREF: challenge6+2C↓j</span><br><span class="line">.text:0000000000001108 20 00 80 52                   MOV             W0, #1</span><br><span class="line">.text:000000000000110C E0 1F 00 B9                   STR             W0, [SP,#0x20+var_4]</span><br><span class="line">.text:000000000000110C</span><br><span class="line">.text:0000000000001110</span><br><span class="line">.text:0000000000001110                               loc_1110                                ; CODE XREF: challenge6+14↑j</span><br><span class="line">.text:0000000000001110 E0 6F 40 39                   LDRB            W0, [SP,#0x20+var_5]</span><br><span class="line">.text:0000000000001114 00 1C 00 12                   AND             W0, W0, #0xFF</span><br><span class="line">.text:0000000000001118 1F 00 00 71                   CMP             W0, #0</span><br><span class="line">.text:000000000000111C 61 FF FF 54                   B.NE            loc_1108</span><br><span class="line">.text:000000000000111C</span><br><span class="line">.text:0000000000001120 E0 07 40 F9                   LDR             X0, [SP,#0x20+var_18]</span><br><span class="line">.text:0000000000001124 21 00 80 52                   MOV             W1, #1</span><br><span class="line">.text:0000000000001128 01 00 00 39                   STRB            W1, [X0]</span><br><span class="line">.text:000000000000112C 1F 20 03 D5                   NOP</span><br><span class="line">.text:0000000000001130 FF 83 00 91                   ADD             SP, SP, #0x20 ; &#x27; &#x27;</span><br><span class="line">.text:0000000000001134 C0 03 5F D6                   RET</span><br><span class="line">.text:0000000000001134                               ; &#125; // starts at 10F0</span><br><span class="line">.text:0000000000001134</span><br><span class="line">.text:0000000000001134                               ; End of function challenge6</span><br></pre></td></tr></table></figure>

<p>根据汇编可以知道，首先在<code>0x10FC</code>处将<code>1</code>存进了栈中，然后在<code>0x1110</code>处取了出来，<code>AND</code>了之后拿去和<code>0</code>做比较，比较不等则一直循环</p>
<p>由于<code>hook</code>操作是在指令执行前确定的，所以可以在<code>0x1114</code>处或<code>0x1118</code>处将<code>W0</code>改为<code>0</code>，处理方法和challenge4类似</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hook_1118</span>(<span class="params">ql: Qiling</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    .text:0000000000001114 00 1C 00 12                   AND             W0, W0, #0xFF</span></span><br><span class="line"><span class="string">    .text:0000000000001118 1F 00 00 71                   CMP             W0, #0</span></span><br><span class="line"><span class="string">    .text:000000000000111C 61 FF FF 54                   B.NE            loc_1108</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    ql.arch.regs.w0 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge6</span>(<span class="params">ql: Qiling</span>):</span><br><span class="line">    base_addr = ql.mem.get_lib_base(os.path.split(ql.path)[-<span class="number">1</span>]) <span class="comment"># 需要先搞到基地址</span></span><br><span class="line">    stop_loop = base_addr + <span class="number">0x1118</span> <span class="comment"># 基地址+偏移</span></span><br><span class="line">    ql.hook_address(hook_1118,stop_loop)</span><br></pre></td></tr></table></figure>

<p>此时challenge5的结果可以正常打印，但challenge6的没打印</p>
<h3 id="Challenge-7-Don’t-waste-time-waiting-for-‘sleep’"><a href="#Challenge-7-Don’t-waste-time-waiting-for-‘sleep’" class="headerlink" title="Challenge 7: Don’t waste time waiting for ‘sleep’."></a>Challenge 7: Don’t waste time waiting for ‘sleep’.</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">challenge7</span><span class="params">(_BYTE *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  *a1 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> sleep(<span class="number">0xFFFFFFFF</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法很多，此处列三种</p>
<p>1.将<code>sleep</code>过掉，直接返回</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hook_sleep_func</span>(<span class="params">ql: Qiling</span>):</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge7</span>(<span class="params">ql: Qiling</span>):</span><br><span class="line">    ql.os.set_api(<span class="string">&#x27;sleep&#x27;</span>,hook_sleep_func)</span><br></pre></td></tr></table></figure>

<p>2.在函数<code>sleep</code>调用前把<code>w0</code>改为<code>0</code>就行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hook_1154</span>(<span class="params">ql: Qiling</span>):</span><br><span class="line">    ql.arch.regs.w0=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge7</span>(<span class="params">ql: Qiling</span>):</span><br><span class="line">    base_addr = ql.mem.get_lib_base(os.path.split(ql.path)[-<span class="number">1</span>]) <span class="comment"># 需要先搞到基地址</span></span><br><span class="line">    hook_sleep = base_addr + <span class="number">0x1154</span> <span class="comment"># 基地址+偏移</span></span><br><span class="line">    ql.hook_address(hook_1154,hook_sleep)</span><br></pre></td></tr></table></figure>

<p>3.将底层的<code>nanosleep</code>过掉</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hook_nanosleep_func</span>(<span class="params">ql: Qiling</span>):</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge7</span>(<span class="params">ql: Qiling</span>):</span><br><span class="line">    ql.os.set_syscall(<span class="string">&#x27;nanosleep&#x27;</span>,hook_nanosleep_func)</span><br></pre></td></tr></table></figure>

<p>总之舞台很大，而且challenge7过了之后后面的内容都能打印了</p>
<h3 id="Challenge-8-Unpack-the-struct-and-write-at-the-target-address"><a href="#Challenge-8-Unpack-the-struct-and-write-at-the-target-address" class="headerlink" title="Challenge 8: Unpack the struct and write at the target address."></a>Challenge 8: Unpack the struct and write at the target address.</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_DWORD *__fastcall <span class="title function_">challenge8</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  _DWORD *result; <span class="comment">// x0</span></span><br><span class="line">  _DWORD *v3; <span class="comment">// [xsp+28h] [xbp+28h]</span></span><br><span class="line"></span><br><span class="line">  v3 = <span class="built_in">malloc</span>(<span class="number">0x18</span>uLL); <span class="comment">// 申请了一个0x18（24 Bytes）的空间</span></span><br><span class="line">  *(_QWORD *)v3 = <span class="built_in">malloc</span>(<span class="number">0x1E</span>uLL);<span class="comment">// 申请了一个0x1E(30 Bytes)的空间，并将指向这个空间的指针存到v3的前8 Bytes中</span></span><br><span class="line">  v3[<span class="number">2</span>] = <span class="number">1337</span>; <span class="comment">// 将数1337存入v3的8~12 Bytes中</span></span><br><span class="line">  v3[<span class="number">3</span>] = <span class="number">1039980266</span>; <span class="comment">// 将数1039980266存入v3的12~16 Bytes中</span></span><br><span class="line">  <span class="built_in">strcpy</span>(*(<span class="type">char</span> **)v3, <span class="string">&quot;Random data&quot;</span>); <span class="comment">// 将字符串&quot;Random data&quot;存入申请的30 Bytes空间中</span></span><br><span class="line">  result = v3;</span><br><span class="line">  *((_QWORD *)v3 + <span class="number">2</span>) = a1; <span class="comment">// 将a1(指针)存入v3最后的剩余空间(8 BYtes)中</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据伪代码与分析，可以知道结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *str;		<span class="comment">// 8 字节的指针，指向字符串 &quot;Random data&quot; 所在的内存</span></span><br><span class="line">    <span class="type">uint32_t</span> v1;	<span class="comment">// 4 字节的整数，值为 1337</span></span><br><span class="line">    <span class="type">uint32_t</span> v2;	<span class="comment">// 4 字节的整数，值为 1039980266</span></span><br><span class="line">    <span class="type">int64_t</span> check;	<span class="comment">// 8 字节的整数，值为传入的参数 a1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这边有两种方法可以完成挑战</p>
<p>1.在函数汇编的<code>ret</code>前可以找到结构体存储的位置，从而对结构体内容进行修改</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hook_11DC</span>(<span class="params">ql: Qiling</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    .text:00000000000011D0 E0 17 40 F9                   LDR             X0, [SP,#0x30+var_8]</span></span><br><span class="line"><span class="string">    .text:00000000000011D4 E1 0F 40 F9                   LDR             X1, [SP,#0x30+var_18]</span></span><br><span class="line"><span class="string">    .text:00000000000011D8 01 08 00 F9                   STR             X1, [X0,#0x10]</span></span><br><span class="line"><span class="string">    .text:00000000000011DC 1F 20 03 D5                   NOP</span></span><br><span class="line"><span class="string">    .text:00000000000011E0 FD 7B C3 A8                   LDP             X29, X30, [SP+0x30+var_30],#0x30</span></span><br><span class="line"><span class="string">    .text:00000000000011E4 C0 03 5F D6                   RET</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    heap_struct_addr = ql.unpack64(ql.mem.read(ql.arch.regs.sp + <span class="number">0x28</span>, <span class="number">8</span>))   <span class="comment"># 获取堆中存结构体的地址</span></span><br><span class="line">    <span class="comment"># 这边是根据返回值来确认堆中存结构体的地址的</span></span><br><span class="line">    <span class="comment"># 因为返回的寄存器是X0，因此找到给X0赋值的地方就能找到指针了</span></span><br><span class="line">    <span class="comment"># 或者可以用IDA的猜测功能，在反编译窗口选中result = v3处点tab键就可以定位执行这个操作的对应汇编地址</span></span><br><span class="line">    heap_struct = ql.mem.read(heap_struct_addr, <span class="number">24</span>)                          <span class="comment"># dump堆内容</span></span><br><span class="line">    string_addr, magic, check_addr = struct.unpack(<span class="string">&#x27;QQQ&#x27;</span>, heap_struct)       <span class="comment"># 解包结构体</span></span><br><span class="line">    ql.mem.write(check_addr, <span class="string">b&quot;\x01&quot;</span>)                                        <span class="comment"># 写内容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge8</span>(<span class="params">ql: Qiling</span>):</span><br><span class="line">    base_addr = ql.mem.get_lib_base(os.path.split(ql.path)[-<span class="number">1</span>]) <span class="comment"># 需要先搞到基地址</span></span><br><span class="line">    hook_struct = base_addr + <span class="number">0x11DC</span> <span class="comment"># 基地址+偏移</span></span><br><span class="line">    ql.hook_address(hook_11DC,hook_struct)</span><br></pre></td></tr></table></figure>

<p>2.使用Qiling提供的强大的<a target="_blank" rel="noopener" href="https://docs.qiling.io/en/latest/memory/#:~:text=Search%20bytes%20pattern%20from%20memory">search功能</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hook_11DC</span>(<span class="params">ql: Qiling</span>):</span><br><span class="line">    MAGIC = <span class="number">0x3DFCD6EA00000539</span> <span class="comment"># 由于魔数分为两部分，为了搜索更精确，将其进行合并，搜索一个8 Bytes的大数</span></span><br><span class="line">    magic_addrs = ql.mem.search(ql.pack64(MAGIC)) </span><br><span class="line">    <span class="keyword">for</span> magic_addr <span class="keyword">in</span> magic_addrs:</span><br><span class="line">        <span class="comment"># 搜索出来的结构体可能不是需要的，因此要解包进行判断</span></span><br><span class="line">        candidate_heap_struct_addr = magic_addr - <span class="number">8</span></span><br><span class="line">        candidate_heap_struct = ql.mem.read(candidate_heap_struct_addr, <span class="number">24</span>)</span><br><span class="line">        string_addr, _ , check_addr = struct.unpack(<span class="string">&#x27;QQQ&#x27;</span>, candidate_heap_struct)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 判断是否是正确的结构体</span></span><br><span class="line">        <span class="keyword">if</span> ql.mem.string(string_addr) == <span class="string">&quot;Random data&quot;</span>:</span><br><span class="line">            <span class="comment"># 正确则写一个字节在最后的指针里面</span></span><br><span class="line">            ql.mem.write(check_addr, <span class="string">b&quot;\x01&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge8</span>(<span class="params">ql: Qiling</span>):</span><br><span class="line">    base_addr = ql.mem.get_lib_base(os.path.split(ql.path)[-<span class="number">1</span>]) <span class="comment"># 需要先搞到基地址</span></span><br><span class="line">    hook_struct = base_addr + <span class="number">0x11DC</span> <span class="comment"># 基地址+偏移</span></span><br><span class="line">    ql.hook_address(hook_11DC,hook_struct)</span><br></pre></td></tr></table></figure>

<h3 id="Challenge-9-Fix-some-string-operation-to-make-the-iMpOsSiBlE-come-true"><a href="#Challenge-9-Fix-some-string-operation-to-make-the-iMpOsSiBlE-come-true" class="headerlink" title="Challenge 9: Fix some string operation to make the iMpOsSiBlE come true."></a>Challenge 9: Fix some string operation to make the iMpOsSiBlE come true.</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">challenge9</span><span class="params">(<span class="type">bool</span> *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *i; <span class="comment">// [xsp+20h] [xbp+20h]</span></span><br><span class="line">  <span class="type">char</span> dest[<span class="number">32</span>]; <span class="comment">// [xsp+28h] [xbp+28h] BYREF</span></span><br><span class="line">  <span class="type">char</span> src[<span class="number">32</span>]; <span class="comment">// [xsp+48h] [xbp+48h] BYREF</span></span><br><span class="line">  __int64 v6; <span class="comment">// [xsp+68h] [xbp+68h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(src, <span class="string">&quot;aBcdeFghiJKlMnopqRstuVWxYz&quot;</span>);</span><br><span class="line">  src[<span class="number">27</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(dest, src);</span><br><span class="line">  <span class="keyword">for</span> ( i = dest; *i; ++i )</span><br><span class="line">    *i = <span class="built_in">tolower</span>((<span class="type">unsigned</span> __int8)*i);</span><br><span class="line">  *a1 = <span class="built_in">strcmp</span>(src, dest) == <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> v6 ^ _stack_chk_guard;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接<code>hook</code>掉<code>tolower</code>函数就行</p>
<h3 id="Challenge-10-Fake-the-‘cmdline’-line-file-to-return-the-right-content"><a href="#Challenge-10-Fake-the-‘cmdline’-line-file-to-return-the-right-content" class="headerlink" title="Challenge 10: Fake the ‘cmdline’ line file to return the right content."></a>Challenge 10: Fake the ‘cmdline’ line file to return the right content.</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">challenge10</span><span class="params">(_BYTE *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [xsp+28h] [xbp+28h]</span></span><br><span class="line">  <span class="type">int</span> fd; <span class="comment">// [xsp+2Ch] [xbp+2Ch]</span></span><br><span class="line">  <span class="type">ssize_t</span> v5; <span class="comment">// [xsp+30h] [xbp+30h]</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">64</span>]; <span class="comment">// [xsp+38h] [xbp+38h] BYREF</span></span><br><span class="line">  __int64 v7; <span class="comment">// [xsp+78h] [xbp+78h]</span></span><br><span class="line"></span><br><span class="line">  fd = open(<span class="string">&quot;/proc/self/cmdline&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( fd != <span class="number">-1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v5 = read(fd, buf, <span class="number">0x3F</span>uLL);</span><br><span class="line">    <span class="keyword">if</span> ( v5 &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      close(fd);</span><br><span class="line">      <span class="keyword">for</span> ( i = <span class="number">0</span>; v5 &gt; i; ++i )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( !buf[i] )</span><br><span class="line">          buf[i] = <span class="number">32</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      buf[v5] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(buf, <span class="string">&quot;qilinglab&quot;</span>) )</span><br><span class="line">        *a1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v7 ^ _stack_chk_guard;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考challenge3就可以了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fakecmdline</span>(<span class="title class_ inherited__">QlFsMappedObject</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">self, size: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bytes</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&quot;qilinglab&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge10</span>(<span class="params">ql: Qiling</span>):</span><br><span class="line">    ql.add_fs_mapper(<span class="string">&quot;/proc/self/cmdline&quot;</span>, Fakecmdline())</span><br></pre></td></tr></table></figure>

<h3 id="Challenge-11-Bypass-CPUID-MIDR-EL1-checks"><a href="#Challenge-11-Bypass-CPUID-MIDR-EL1-checks" class="headerlink" title="Challenge 11: Bypass CPUID&#x2F;MIDR_EL1 checks."></a>Challenge 11: Bypass CPUID&#x2F;MIDR_EL1 checks.</h3><p>这题<code>X86/64</code>和<code>aarch64</code>的实现方式不同，都做一遍</p>
<h4 id="首先是ARM64"><a href="#首先是ARM64" class="headerlink" title="首先是ARM64"></a>首先是ARM64</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">challenge11</span><span class="params">(_BYTE *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// x0</span></span><br><span class="line"></span><br><span class="line">  result = <span class="number">4919LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( _ReadStatusReg(ARM64_SYSREG(<span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)) &gt;&gt; <span class="number">16</span> == <span class="number">4919</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = (__int64)a1;</span><br><span class="line">    *a1 = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里用到了一个ARM架构的特殊寄存器<a target="_blank" rel="noopener" href="https://developer.arm.com/documentation/ddi0595/2020-12/AArch64-Registers/MIDR-EL1--Main-ID-Register"><code>midr_el1</code></a>以及配套的汇编指令<a target="_blank" rel="noopener" href="https://www.scs.stanford.edu/~zyedidia/arm64/mrs.html"><code>MRS</code></a>，对应的函数为<a target="_blank" rel="noopener" href="https://www.scs.stanford.edu/~zyedidia/arm64/shared_pseudocode.html#AArch64.SysRegRead.6">AArch64.SysRegRead</a></p>
<p>而这个<code>midr_el1</code>的使用例可以看<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/234822747#:~:text=%E7%9B%B4%E8%A7%82%E7%9A%84%E5%86%85%E5%AE%B9%E3%80%82-,3.%E4%BD%BF%E7%94%A8%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%E5%92%8C%E8%BE%85%E5%8A%A9%E5%90%91%E9%87%8F%E7%9B%B4%E6%8E%A5%E8%A7%A3%E6%9E%90,-%E4%B8%8A%E6%96%87%E4%BB%8B%E7%BB%8D">这个</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000000013EC 00 00 38 D5                   MRS             X0, #0, c0, c0, #0</span><br></pre></td></tr></table></figure>

<p>其作用是读取机器信息，这条完整的<code>MRS</code>指令每一位的含义如下</p>
<table>
<thead>
<tr>
<th>31</th>
<th>30</th>
<th>29</th>
<th>28</th>
<th>27</th>
<th>26</th>
<th>25</th>
<th>24</th>
<th>23</th>
<th>22</th>
<th>21</th>
<th>20</th>
<th>19</th>
<th>18</th>
<th>17</th>
<th>16</th>
<th>15</th>
<th>14</th>
<th>13</th>
<th>12</th>
<th>11</th>
<th>10</th>
<th>9</th>
<th>8</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>o0</td>
<td>op1</td>
<td>op1</td>
<td>op1</td>
<td>CRn</td>
<td>CRn</td>
<td>CRn</td>
<td>CRn</td>
<td>CRm</td>
<td>CRm</td>
<td>CRm</td>
<td>CRm</td>
<td>op2</td>
<td>op2</td>
<td>op2</td>
<td>Rt</td>
<td>Rt</td>
<td>Rt</td>
<td>Rt</td>
<td>Rt</td>
</tr>
</tbody></table>
<blockquote>
<p>需要注意第十九位<code>o0</code>实际上是<strong>两位</strong>，只是<strong>高位都为1</strong>就省略掉了，即它的值为2或3</p>
</blockquote>
<p>这条指令中的<code>o0</code>、<code>op1</code>、<code>CRn</code>、<code>CRm</code>、<code>op2</code>的组合用于指示从哪个寄存器中取值，而<code>Rt</code>表示取到哪个寄存器去</p>
<p>简单来说，指令<code>MRS</code>就是从<code>midr_el1</code>读取了信息然后存到了<code>X0</code>里面，然后就对<code>X0</code>的内容进行了判断</p>
<p>所以要过这关需要让<code>X0</code>的值变为指定内容</p>
<p>这里用到Qiling提供的<a target="_blank" rel="noopener" href="https://docs.qiling.io/en/latest/hook/#:~:text=ql.hook_code(callback%3A%20Callable%2C%20user_data%3A%20Any%20%3D%20None)"><code>hook_code</code></a>函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">midr_el1_hook</span>(<span class="params">ql: Qiling, address, size</span>):  </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    .text:00000000000013EC 00 00 38 D5                   MRS             X0, #0, c0, c0, #0</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">#hook_code函数每一条指令都会执行一次，因此要注意加判断条件</span></span><br><span class="line">    <span class="keyword">if</span> ql.mem.read(address, size) == <span class="string">b&quot;\x00\x00\x38\xD5&quot;</span>:</span><br><span class="line">        <span class="comment"># 直接改接收midr_el1值的寄存器</span></span><br><span class="line">        ql.arch.regs.X0 = <span class="number">0x1337</span> &lt;&lt; <span class="number">16</span></span><br><span class="line">        <span class="comment"># 别忘了直接跳过不让原来的指令执行（以字节为单位执行指令，所以这里要跳过4字节）</span></span><br><span class="line">        ql.arch.regs.arch_pc += <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge11</span>(<span class="params">ql: Qiling</span>):</span><br><span class="line">    ql.hook_code(midr_el1_hook)</span><br></pre></td></tr></table></figure>

<p>但是hook_code函数每一条指令都会执行一次，这使得效率非常的低，因此考虑进行分段操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">midr_el1_hook</span>(<span class="params">ql: Qiling, address, size</span>):  </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    .text:00000000000013EC 00 00 38 D5                   MRS             X0, #0, c0, c0, #0</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">#hook_code函数每一条指令都会执行一次，因此要注意加判断条件</span></span><br><span class="line">    <span class="keyword">if</span> ql.mem.read(address, size) == <span class="string">b&quot;\x00\x00\x38\xD5&quot;</span>:</span><br><span class="line">        <span class="comment"># 直接改接收midr_el1值的寄存器</span></span><br><span class="line">        ql.arch.regs.X0 = <span class="number">0x1337</span> &lt;&lt; <span class="number">16</span></span><br><span class="line">        <span class="comment"># 别忘了直接跳过不让原来的指令执行（以字节为单位执行指令，所以这里要跳过4字节）</span></span><br><span class="line">        ql.arch.regs.arch_pc += <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge11</span>(<span class="params">ql: Qiling</span>):</span><br><span class="line">    mem_map = ql.mem.map_info <span class="comment"># 获取所有映射的信息</span></span><br><span class="line">    <span class="keyword">for</span> entry <span class="keyword">in</span> mem_map:</span><br><span class="line">        <span class="comment"># entry内容为range start, range end, permissions mask, range label, is mmio</span></span><br><span class="line">        start, end, flags, label, _ = entry</span><br><span class="line">        <span class="comment"># 取目标hook地址所在的映射区域</span></span><br><span class="line">        <span class="comment"># [=]     555555554000 - 555555556000   r-x (5)    [redacted]/qilinglab-aarch64 </span></span><br><span class="line">        <span class="keyword">if</span> os.path.split(ql.path)[-<span class="number">1</span>] <span class="keyword">in</span> label <span class="keyword">and</span> flags == <span class="number">5</span>:</span><br><span class="line">            start_hook = start</span><br><span class="line">            end_hook = end</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 使用begin和end参数来指定hook的范围（采用base+偏移的方法实际上能缩得更短，不过都这样了为啥不用hook_address呢）</span></span><br><span class="line">    ql.hook_code(midr_el1_hook, begin=start_hook, end=end_hook)</span><br></pre></td></tr></table></figure>

<p>当然也可以直接hook掉MRS所在的地址</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">midr_el1_hook</span>(<span class="params">ql: Qiling</span>):</span><br><span class="line">    <span class="comment"># 直接改接收midr_el1值的寄存器</span></span><br><span class="line">    ql.arch.regs.X0 = <span class="number">0x1337</span> &lt;&lt; <span class="number">16</span></span><br><span class="line">    <span class="comment"># 别忘了直接跳过不让原来的指令执行（以字节为单位执行指令，所以这里要跳过4字节）</span></span><br><span class="line">    ql.arch.regs.arch_pc += <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge11</span>(<span class="params">ql: Qiling</span>):</span><br><span class="line">    base_addr = ql.mem.get_lib_base(os.path.split(ql.path)[-<span class="number">1</span>])</span><br><span class="line">    MRS_instruction = base_addr+<span class="number">0x13EC</span></span><br><span class="line">    ql.hook_address(midr_el1_hook,MRS_instruction)</span><br></pre></td></tr></table></figure>

<h4 id="再看看X86-64"><a href="#再看看X86-64" class="headerlink" title="再看看X86&#x2F;64"></a>再看看X86&#x2F;64</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">challenge11</span><span class="params">(_BYTE *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [rsp+1Ch] [rbp-34h]</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// [rsp+24h] [rbp-2Ch]</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">4</span>]; <span class="comment">// [rsp+2Bh] [rbp-25h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v10[<span class="number">4</span>]; <span class="comment">// [rsp+2Fh] [rbp-21h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v11[<span class="number">4</span>]; <span class="comment">// [rsp+33h] [rbp-1Dh] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v12; <span class="comment">// [rsp+38h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v12 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  _RAX = <span class="number">0x40000000</span>LL;</span><br><span class="line">  __asm &#123; cpuid &#125; <span class="comment">// 获取cpu信息</span></span><br><span class="line">  v7 = _RCX;</span><br><span class="line">  v8 = _RDX;</span><br><span class="line">  <span class="keyword">if</span> ( __PAIR64__(_RBX, _RCX) == <span class="number">0x696C6951614C676E</span>LL &amp;&amp; (_DWORD)_RDX == <span class="number">538976354</span> )</span><br><span class="line">    *a1 = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">sprintf</span>(s,<span class="string">&quot;%c%c%c%c&quot;</span>,(<span class="type">unsigned</span> <span class="type">int</span>)_RBX,(<span class="type">unsigned</span> <span class="type">int</span>)((<span class="type">int</span>)_RBX &gt;&gt; <span class="number">8</span>),(<span class="type">unsigned</span> <span class="type">int</span>)((<span class="type">int</span>)_RBX &gt;&gt; <span class="number">16</span>),(<span class="type">unsigned</span> <span class="type">int</span>)((<span class="type">int</span>)_RBX &gt;&gt; <span class="number">24</span>));</span><br><span class="line">  <span class="built_in">sprintf</span>(v10,<span class="string">&quot;%c%c%c%c&quot;</span>,(<span class="type">unsigned</span> <span class="type">int</span>)v7,(<span class="type">unsigned</span> <span class="type">int</span>)(v7 &gt;&gt; <span class="number">8</span>),(<span class="type">unsigned</span> <span class="type">int</span>)(v7 &gt;&gt; <span class="number">16</span>),(<span class="type">unsigned</span> <span class="type">int</span>)(v7 &gt;&gt; <span class="number">24</span>));</span><br><span class="line">  <span class="built_in">sprintf</span>(v11,<span class="string">&quot;%c%c%c%c&quot;</span>,(<span class="type">unsigned</span> <span class="type">int</span>)v8,(<span class="type">unsigned</span> <span class="type">int</span>)(v8 &gt;&gt; <span class="number">8</span>),(<span class="type">unsigned</span> <span class="type">int</span>)(v8 &gt;&gt; <span class="number">16</span>),(<span class="type">unsigned</span> <span class="type">int</span>)(v8 &gt;&gt; <span class="number">24</span>));</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v12;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里用到了一个<code>cpuid</code>的汇编指令，可以看看<a target="_blank" rel="noopener" href="https://www.felixcloutier.com/x86/cpuid">这个</a>，介绍了不同功能码下<code>cpuid</code>返回的内容以及返回内容所在的寄存器</p>
<p>不过这里的功能吗是什么都不影响需要hook掉返回的值的操作</p>
<p>根据汇编</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000001191 89 D0                         mov     eax, edx</span><br><span class="line">.text:0000000000001193 89 DE                         mov     esi, ebx</span><br><span class="line">.text:0000000000001195 89 75 D0                      mov     [rbp+var_30], esi</span><br><span class="line">.text:0000000000001198 89 4D CC                      mov     [rbp+var_34], ecx</span><br><span class="line">.text:000000000000119B 89 45 D4                      mov     [rbp+var_2C], eax</span><br><span class="line">.text:000000000000119E 81 7D D0 51 69 6C 69          cmp     [rbp+var_30], 696C6951h</span><br><span class="line">.text:00000000000011A5 75 19                         jnz     short loc_11C0</span><br><span class="line">.text:00000000000011A5</span><br><span class="line">.text:00000000000011A7 81 7D CC 6E 67 4C 61          cmp     [rbp+var_34], 614C676Eh</span><br><span class="line">.text:00000000000011AE 75 10                         jnz     short loc_11C0</span><br><span class="line">.text:00000000000011AE</span><br><span class="line">.text:00000000000011B0 81 7D D4 62 20 20 20          cmp     [rbp+var_2C], 20202062h</span><br><span class="line">.text:00000000000011B7 75 07                         jnz     short loc_11C0</span><br></pre></td></tr></table></figure>

<p>需要更改的寄存器有<code>EDX</code>、<code>EBX</code>、<code>ECX</code></p>
<p>可以使用<code>hook_code</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hook_cpuid</span>(<span class="params">ql: Qiling,address,size</span>):</span><br><span class="line">    <span class="keyword">if</span> ql.mem.read(address, size) == <span class="string">b&#x27;\x0F\xA2&#x27;</span>: <span class="comment"># 对应的 cpuid 指令字节码</span></span><br><span class="line">        ql.arch.regs.edx=<span class="number">0x20202062</span></span><br><span class="line">        ql.arch.regs.ebx=<span class="number">0x696C6951</span></span><br><span class="line">        ql.arch.regs.ecx=<span class="number">0x614C676E</span></span><br><span class="line">        ql.arch.regs.rip += <span class="number">2</span> <span class="comment"># 这里是直接劫持了cpuid，相当于取代cpuid这条指令为寄存器赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge11</span>(<span class="params">ql: Qiling</span>):</span><br><span class="line">    ql.hook_code(hook_cpuid)</span><br></pre></td></tr></table></figure>

<p>也可以用<code>hook_address</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hook_cpuid</span>(<span class="params">ql: Qiling, *args</span>):</span><br><span class="line">    ql.arch.regs.ebx = <span class="number">0x696C6951</span></span><br><span class="line">    ql.arch.regs.ecx = <span class="number">0x614C676E</span></span><br><span class="line">    ql.arch.regs.edx = <span class="number">0x20202062</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Challenge11</span>(<span class="params">ql: Qiling</span>):</span><br><span class="line">    base_addr = ql.mem.get_lib_base(os.path.split(ql.path)[-<span class="number">1</span>])</span><br><span class="line">    cpuid_instruction = base_addr+<span class="number">0x1191</span> <span class="comment"># 注意这里是在cpuid执行后再修改</span></span><br><span class="line">    ql.hook_address(hook_cpuid,cpuid_instruction)</span><br></pre></td></tr></table></figure>

<h3 id="Challenge-Finished"><a href="#Challenge-Finished" class="headerlink" title="Challenge Finished!"></a>Challenge Finished!</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Welcome to QilingLab.</span><br><span class="line">Here is the list of challenges:</span><br><span class="line">Challenge 1: Store 1337 at pointer 0x1337.</span><br><span class="line">Challenge 2: Make the <span class="string">&#x27;uname&#x27;</span> syscall <span class="built_in">return</span> the correct values.</span><br><span class="line">Challenge 3: Make <span class="string">&#x27;/dev/urandom&#x27;</span> and <span class="string">&#x27;getrandom&#x27;</span> <span class="string">&quot;collide&quot;</span>.</span><br><span class="line">Challenge 4: Enter inside the <span class="string">&quot;forbidden&quot;</span> loop.</span><br><span class="line">Challenge 5: Guess every call to rand().</span><br><span class="line">Challenge 6: Avoid the infinite loop.</span><br><span class="line">Challenge 7: Don<span class="string">&#x27;t waste time waiting for &#x27;</span><span class="built_in">sleep</span><span class="string">&#x27;.</span></span><br><span class="line"><span class="string">Challenge 8: Unpack the struct and write at the target address.</span></span><br><span class="line"><span class="string">Challenge 9: Fix some string operation to make the iMpOsSiBlE come true.</span></span><br><span class="line"><span class="string">Challenge 10: Fake the &#x27;</span>cmdline<span class="string">&#x27; line file to return the right content.</span></span><br><span class="line"><span class="string">Challenge 11: Bypass CPUID/MIDR_EL1 checks.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Checking which challenge are solved...</span></span><br><span class="line"><span class="string">Note: Some challenges will results in segfaults and infinite loops if they aren&#x27;</span>t solved.</span><br><span class="line"></span><br><span class="line">Challenge 1: SOLVED</span><br><span class="line">Challenge 2: SOLVED</span><br><span class="line">Challenge 3: SOLVED</span><br><span class="line">Challenge 4: SOLVED</span><br><span class="line">Challenge 5: SOLVED</span><br><span class="line">Challenge 6: SOLVED</span><br><span class="line">Challenge 7: SOLVED</span><br><span class="line">Challenge 8: SOLVED</span><br><span class="line">Challenge 9: SOLVED</span><br><span class="line">Challenge 10: SOLVED</span><br><span class="line">Challenge 11: SOLVED</span><br><span class="line">You solved 11/11 of the challenges</span><br></pre></td></tr></table></figure>

<p>整个代码文件如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qiling <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> qiling.const <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> qiling.os.mapper <span class="keyword">import</span> QlFsMappedObject</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge1</span>(<span class="params">ql: Qiling</span>):</span><br><span class="line">    ql.mem.<span class="built_in">map</span>(<span class="number">0x1000</span>,<span class="number">0x1000</span>)</span><br><span class="line">    ql.mem.write(<span class="number">0x1337</span>,ql.pack16(<span class="number">1337</span>)) <span class="comment"># pack16(value) == struct.pack(&#x27;H&#x27;, value)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################################################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hook_uname_func</span>(<span class="params">ql: Qiling,*args</span>):</span><br><span class="line">    x0 = ql.arch.regs.sp + <span class="number">0x1F0</span> - <span class="number">0x1B0</span></span><br><span class="line">    ql.mem.write(x0,<span class="string">b&#x27;QilingOS\x00&#x27;</span>)</span><br><span class="line">    ql.mem.write(x0+<span class="number">65</span>*<span class="number">3</span>,<span class="string">b&#x27;ChallengeStart\x00&#x27;</span>) <span class="comment"># (x0+65*3）跳过nodename和release</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge2</span>(<span class="params">ql: Qiling</span>):</span><br><span class="line">    ql.os.set_syscall(<span class="string">&quot;uname&quot;</span>, hook_uname_func, QL_INTERCEPT.EXIT)</span><br><span class="line"></span><br><span class="line"><span class="comment">################################################################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FakeUrandom</span>(<span class="title class_ inherited__">QlFsMappedObject</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">self, size: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bytes</span>:</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">b&#x27;\xE9&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&quot;\x00&quot;</span>*size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hook_getrandom_func</span>(<span class="params">ql: Qiling,buf,buflen</span>):</span><br><span class="line">    ql.mem.write(buf,<span class="string">b&#x27;\x00&#x27;</span>*buflen)</span><br><span class="line">    ql.os.set_syscall_return(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge3</span>(<span class="params">ql: Qiling</span>):</span><br><span class="line">    ql.os.set_syscall(<span class="string">&quot;getrandom&quot;</span>, hook_getrandom_func)</span><br><span class="line">    ql.add_fs_mapper(<span class="string">&quot;/dev/urandom&quot;</span>, FakeUrandom())</span><br><span class="line"></span><br><span class="line"><span class="comment">################################################################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hook_FE4</span>(<span class="params">ql: Qiling</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    .text:0000000000000FE0 3F 00 00 6B                   CMP             W1, W0</span></span><br><span class="line"><span class="string">    .text:0000000000000FE4 EB FE FF 54                   B.LT            loc_FC0</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    ql.arch.regs.W0 = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge4</span>(<span class="params">ql: Qiling</span>):</span><br><span class="line">    <span class="comment"># 根据文件路径查找已经加载的文件，获取对应文件的基地址</span></span><br><span class="line">    <span class="comment"># os.path.split(ql.path)：os.path.split 函数将 ql.path 分成两部分：目录名和基本文件名。这个函数返回一个包含这两部分的元组。</span></span><br><span class="line">    <span class="comment"># os.path.split(ql.path)[-1]：这将返回元组中的最后一个元素，即基本文件名。在 Python 中，-1 索引表示列表或元组的最后一个元素。</span></span><br><span class="line">    <span class="comment"># base = ql.mem.get_lib_base(os.path.split(ql.path)[-1])：ql.mem.get_lib_base 函数使用提取的文件名作为参数，以获取已加载库的基地址。将返回的基地址赋值给变量 base</span></span><br><span class="line">    base_addr = ql.mem.get_lib_base(os.path.split(ql.path)[-<span class="number">1</span>]) <span class="comment"># 需要先搞到基地址</span></span><br><span class="line">    enter_loop = base_addr + <span class="number">0xfe0</span> <span class="comment"># 基地址+偏移</span></span><br><span class="line">    ql.hook_address(hook_FE4,enter_loop)</span><br><span class="line"></span><br><span class="line"><span class="comment">################################################################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hook_rand_func</span>(<span class="params">ql: Qiling</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    返回值存在w0中</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    ql.arch.regs.W0=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge5</span>(<span class="params">ql:Qiling</span>):</span><br><span class="line">    ql.os.set_api(<span class="string">&#x27;rand&#x27;</span>,hook_rand_func, QL_INTERCEPT.CALL) <span class="comment"># 不同于syscall，库函数要用set_api</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################################################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hook_1118</span>(<span class="params">ql: Qiling</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    .text:0000000000001114 00 1C 00 12                   AND             W0, W0, #0xFF</span></span><br><span class="line"><span class="string">    .text:0000000000001118 1F 00 00 71                   CMP             W0, #0</span></span><br><span class="line"><span class="string">    .text:000000000000111C 61 FF FF 54                   B.NE            loc_1108</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    ql.arch.regs.w0 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge6</span>(<span class="params">ql: Qiling</span>):</span><br><span class="line">    base_addr = ql.mem.get_lib_base(os.path.split(ql.path)[-<span class="number">1</span>]) <span class="comment"># 需要先搞到基地址</span></span><br><span class="line">    stop_loop = base_addr + <span class="number">0x1118</span> <span class="comment"># 基地址+偏移</span></span><br><span class="line">    ql.hook_address(hook_1118,stop_loop)</span><br><span class="line"></span><br><span class="line"><span class="comment">################################################################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># def hook_sleep_func(ql: Qiling):</span></span><br><span class="line"><span class="comment">#     return</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># def challenge7(ql: Qiling):</span></span><br><span class="line"><span class="comment">#     ql.os.set_api(&#x27;sleep&#x27;,hook_sleep_func)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># def hook_1154(ql: Qiling):</span></span><br><span class="line"><span class="comment">#     ql.arch.regs.w0=0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># def challenge7(ql: Qiling):</span></span><br><span class="line"><span class="comment">#     base_addr = ql.mem.get_lib_base(os.path.split(ql.path)[-1]) # 需要先搞到基地址</span></span><br><span class="line"><span class="comment">#     hook_sleep = base_addr + 0x1154 # 基地址+偏移</span></span><br><span class="line"><span class="comment">#     ql.hook_address(hook_1154,hook_sleep)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hook_nanosleep_func</span>(<span class="params">ql: Qiling</span>):</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge7</span>(<span class="params">ql: Qiling</span>):</span><br><span class="line">    ql.os.set_syscall(<span class="string">&#x27;nanosleep&#x27;</span>,hook_nanosleep_func)</span><br><span class="line"></span><br><span class="line"><span class="comment">################################################################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># def hook_11DC(ql: Qiling):</span></span><br><span class="line"><span class="comment">#     &#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#     .text:00000000000011D0 E0 17 40 F9                   LDR             X0, [SP,#0x30+var_8]</span></span><br><span class="line"><span class="comment">#     .text:00000000000011D4 E1 0F 40 F9                   LDR             X1, [SP,#0x30+var_18]</span></span><br><span class="line"><span class="comment">#     .text:00000000000011D8 01 08 00 F9                   STR             X1, [X0,#0x10]</span></span><br><span class="line"><span class="comment">#     .text:00000000000011DC 1F 20 03 D5                   NOP</span></span><br><span class="line"><span class="comment">#     .text:00000000000011E0 FD 7B C3 A8                   LDP             X29, X30, [SP+0x30+var_30],#0x30</span></span><br><span class="line"><span class="comment">#     .text:00000000000011E4 C0 03 5F D6                   RET</span></span><br><span class="line"><span class="comment">#     &#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#     heap_struct_addr = ql.unpack64(ql.mem.read(ql.arch.regs.sp + 0x28, 8))   # 获取堆中存结构体的地址</span></span><br><span class="line"><span class="comment">#     # 这边是根据返回值来确认堆中存结构体的地址的</span></span><br><span class="line"><span class="comment">#     # 因为返回的寄存器是X0，因此找到给X0赋值的地方就能找到指针了</span></span><br><span class="line"><span class="comment">#     # 或者可以用IDA的猜测功能，在反编译窗口选中result = v3处点tab键就可以定位执行这个操作的对应汇编地址</span></span><br><span class="line"><span class="comment">#     heap_struct = ql.mem.read(heap_struct_addr, 24)                          # dump堆内容</span></span><br><span class="line"><span class="comment">#     string_addr, magic, check_addr = struct.unpack(&#x27;QQQ&#x27;, heap_struct)       # 解包结构体</span></span><br><span class="line"><span class="comment">#     ql.mem.write(check_addr, b&quot;\x01&quot;)                                        # 写内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># def challenge8(ql: Qiling):</span></span><br><span class="line"><span class="comment">#     base_addr = ql.mem.get_lib_base(os.path.split(ql.path)[-1]) # 需要先搞到基地址</span></span><br><span class="line"><span class="comment">#     hook_struct = base_addr + 0x11DC # 基地址+偏移</span></span><br><span class="line"><span class="comment">#     ql.hook_address(hook_11DC,hook_struct)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hook_11DC</span>(<span class="params">ql: Qiling</span>):</span><br><span class="line">    MAGIC = <span class="number">0x3DFCD6EA00000539</span> <span class="comment"># 由于魔数分为两部分，为了搜索更精确，将其进行合并，搜索一个8 Bytes的大数</span></span><br><span class="line">    magic_addrs = ql.mem.search(ql.pack64(MAGIC)) </span><br><span class="line">    <span class="keyword">for</span> magic_addr <span class="keyword">in</span> magic_addrs:</span><br><span class="line">        <span class="comment"># 搜索出来的结构体可能不是需要的，因此要解包进行判断</span></span><br><span class="line">        candidate_heap_struct_addr = magic_addr - <span class="number">8</span></span><br><span class="line">        candidate_heap_struct = ql.mem.read(candidate_heap_struct_addr, <span class="number">24</span>)</span><br><span class="line">        string_addr, _ , check_addr = struct.unpack(<span class="string">&#x27;QQQ&#x27;</span>, candidate_heap_struct)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 判断是否是正确的结构体</span></span><br><span class="line">        <span class="keyword">if</span> ql.mem.string(string_addr) == <span class="string">&quot;Random data&quot;</span>:</span><br><span class="line">            <span class="comment"># 正确则写一个字节在最后的指针里面</span></span><br><span class="line">            ql.mem.write(check_addr, <span class="string">b&quot;\x01&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge8</span>(<span class="params">ql: Qiling</span>):</span><br><span class="line">    base_addr = ql.mem.get_lib_base(os.path.split(ql.path)[-<span class="number">1</span>]) <span class="comment"># 需要先搞到基地址</span></span><br><span class="line">    hook_struct = base_addr + <span class="number">0x11DC</span> <span class="comment"># 基地址+偏移</span></span><br><span class="line">    ql.hook_address(hook_11DC,hook_struct)</span><br><span class="line"></span><br><span class="line"><span class="comment">################################################################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hook_tolower_func</span>(<span class="params">ql: Qiling</span>):</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge9</span>(<span class="params">ql: Qiling</span>):</span><br><span class="line">    ql.os.set_api(<span class="string">&#x27;tolower&#x27;</span>,hook_tolower_func)</span><br><span class="line"></span><br><span class="line"><span class="comment">################################################################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fakecmdline</span>(<span class="title class_ inherited__">QlFsMappedObject</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">self, size: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bytes</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&quot;qilinglab&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge10</span>(<span class="params">ql: Qiling</span>):</span><br><span class="line">    ql.add_fs_mapper(<span class="string">&quot;/proc/self/cmdline&quot;</span>, Fakecmdline())</span><br><span class="line"></span><br><span class="line"><span class="comment">################################################################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">midr_el1_hook</span>(<span class="params">ql: Qiling, address, size</span>):  </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    .text:00000000000013EC 00 00 38 D5                   MRS             X0, #0, c0, c0, #0</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">#hook_code函数每一条指令都会执行一次，因此要注意加判断条件</span></span><br><span class="line">    <span class="keyword">if</span> ql.mem.read(address, size) == <span class="string">b&quot;\x00\x00\x38\xD5&quot;</span>:</span><br><span class="line">        <span class="comment"># 直接改接收midr_el1值的寄存器</span></span><br><span class="line">        ql.arch.regs.X0 = <span class="number">0x1337</span> &lt;&lt; <span class="number">16</span></span><br><span class="line">        <span class="comment"># 别忘了直接跳过不让原来的指令执行（以字节为单位执行指令，所以这里要跳过4字节）</span></span><br><span class="line">        ql.arch.regs.arch_pc += <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># def challenge11(ql: Qiling):</span></span><br><span class="line"><span class="comment">#     ql.hook_code(midr_el1_hook)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge11</span>(<span class="params">ql: Qiling</span>):</span><br><span class="line">    mem_map = ql.mem.map_info <span class="comment"># 获取所有映射的信息</span></span><br><span class="line">    <span class="keyword">for</span> entry <span class="keyword">in</span> mem_map:</span><br><span class="line">        <span class="comment"># entry内容为range start, range end, permissions mask, range label, is mmio?</span></span><br><span class="line">        start, end, flags, label, _ = entry</span><br><span class="line">        <span class="comment"># 取目标hook地址所在的映射区域</span></span><br><span class="line">        <span class="comment"># [=]     555555554000 - 555555556000   r-x (5)    [redacted]/qilinglab-aarch64 </span></span><br><span class="line">        <span class="keyword">if</span> os.path.split(ql.path)[-<span class="number">1</span>] <span class="keyword">in</span> label <span class="keyword">and</span> flags == <span class="number">5</span>:</span><br><span class="line">            start_hook = start</span><br><span class="line">            end_hook = end</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 使用begin和end参数来指定hook的范围（采用base+偏移的方法实际上能缩得更短，不过都这样了为啥不用hook_address呢）</span></span><br><span class="line">    ql.hook_code(midr_el1_hook, begin=start_hook, end=end_hook)</span><br><span class="line"></span><br><span class="line"><span class="comment"># def midr_el1_hook(ql: Qiling):</span></span><br><span class="line"><span class="comment">#     # 直接改接收midr_el1值的寄存器</span></span><br><span class="line"><span class="comment">#     ql.arch.regs.X0 = 0x1337 &lt;&lt; 16</span></span><br><span class="line"><span class="comment">#     # 别忘了直接跳过不让原来的指令执行（以字节为单位执行指令，所以这里要跳过4字节）</span></span><br><span class="line"><span class="comment">#     ql.arch.regs.arch_pc += 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># def challenge11(ql: Qiling):</span></span><br><span class="line"><span class="comment">#     base_addr = ql.mem.get_lib_base(os.path.split(ql.path)[-1])</span></span><br><span class="line"><span class="comment">#     MRS_instruction = base_addr+0x13EC</span></span><br><span class="line"><span class="comment">#     ql.hook_address(midr_el1_hook,MRS_instruction)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__  == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    path = [<span class="string">&#x27;qilinglab/qilinglab-aarch64&#x27;</span>] <span class="comment"># 我们的目标</span></span><br><span class="line">    rootfs = <span class="string">&quot;./examples/rootfs/arm64_linux&quot;</span> <span class="comment"># 在你clone下来的仓库里</span></span><br><span class="line">    ql = Qiling(path, rootfs,verbose= QL_VERBOSE.OFF) <span class="comment"># 关闭了VERBOSE，否则输出太难看了</span></span><br><span class="line">    challenge1(ql) <span class="comment"># 在ql.run()之前，做好我们的hook工作</span></span><br><span class="line">    challenge2(ql)</span><br><span class="line">    challenge3(ql)</span><br><span class="line">    challenge4(ql)</span><br><span class="line">    challenge5(ql)</span><br><span class="line">    challenge6(ql)</span><br><span class="line">    challenge7(ql)</span><br><span class="line">    challenge8(ql)</span><br><span class="line">    challenge9(ql)</span><br><span class="line">    challenge10(ql)</span><br><span class="line">    challenge11(ql)</span><br><span class="line">    ql.run()</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://woaw04.github.io">WoaW04</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://woaw04.github.io/2024/10/01/QilingLab-%E4%B8%8A%E6%89%8BQilingFramework/">https://woaw04.github.io/2024/10/01/QilingLab-%E4%B8%8A%E6%89%8BQilingFramework/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://woaw04.github.io" target="_blank">The Blog of WoaW04</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/RE/">RE</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/WoaW04/Picture/main/202410010015849.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/10/08/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94Frida/" title="安卓逆向学习之路——Frida"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">安卓逆向学习之路——Frida</div></div></a></div><div class="next-post pull-right"><a href="/2024/09/18/2024%E7%BE%8A%E5%9F%8E%E6%9D%AFchal/" title="2024羊城杯chal"><img class="cover" src="https://raw.githubusercontent.com/WoaW04/Picture/main/202409182255885.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">2024羊城杯chal</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://raw.githubusercontent.com/WoaW04/Picture/main/202503031814307.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">WoaW04</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">61</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/WoaW04"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x00-%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">0x00 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x01-%E8%A7%A3"><span class="toc-number">2.</span> <span class="toc-text">0x01 解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Challenge-1-Store-1337-at-pointer-0x1337"><span class="toc-number">2.1.</span> <span class="toc-text">Challenge 1: Store 1337 at pointer 0x1337.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Challenge-2-Make-the-%E2%80%98uname%E2%80%99-syscall-return-the-correct-values"><span class="toc-number">2.2.</span> <span class="toc-text">Challenge 2: Make the ‘uname’ syscall return the correct values.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Challenge-3-Make-%E2%80%98-dev-urandom%E2%80%99-and-%E2%80%98getrandom%E2%80%99-%E2%80%9Ccollide%E2%80%9D"><span class="toc-number">2.3.</span> <span class="toc-text">Challenge 3: Make ‘&#x2F;dev&#x2F;urandom’ and ‘getrandom’ “collide”.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Challenge-4-Enter-inside-the-%E2%80%9Cforbidden%E2%80%9D-loop"><span class="toc-number">2.4.</span> <span class="toc-text">Challenge 4: Enter inside the “forbidden” loop.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Challenge-5-Guess-every-call-to-rand"><span class="toc-number">2.5.</span> <span class="toc-text">Challenge 5: Guess every call to rand().</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Challenge-6-Avoid-the-infinite-loop"><span class="toc-number">2.6.</span> <span class="toc-text">Challenge 6: Avoid the infinite loop.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Challenge-7-Don%E2%80%99t-waste-time-waiting-for-%E2%80%98sleep%E2%80%99"><span class="toc-number">2.7.</span> <span class="toc-text">Challenge 7: Don’t waste time waiting for ‘sleep’.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Challenge-8-Unpack-the-struct-and-write-at-the-target-address"><span class="toc-number">2.8.</span> <span class="toc-text">Challenge 8: Unpack the struct and write at the target address.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Challenge-9-Fix-some-string-operation-to-make-the-iMpOsSiBlE-come-true"><span class="toc-number">2.9.</span> <span class="toc-text">Challenge 9: Fix some string operation to make the iMpOsSiBlE come true.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Challenge-10-Fake-the-%E2%80%98cmdline%E2%80%99-line-file-to-return-the-right-content"><span class="toc-number">2.10.</span> <span class="toc-text">Challenge 10: Fake the ‘cmdline’ line file to return the right content.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Challenge-11-Bypass-CPUID-MIDR-EL1-checks"><span class="toc-number">2.11.</span> <span class="toc-text">Challenge 11: Bypass CPUID&#x2F;MIDR_EL1 checks.</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A6%96%E5%85%88%E6%98%AFARM64"><span class="toc-number">2.11.1.</span> <span class="toc-text">首先是ARM64</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%8D%E7%9C%8B%E7%9C%8BX86-64"><span class="toc-number">2.11.2.</span> <span class="toc-text">再看看X86&#x2F;64</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Challenge-Finished"><span class="toc-number">2.12.</span> <span class="toc-text">Challenge Finished!</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: #FFFFFF00"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2025 By WoaW04</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div></div></body></html>