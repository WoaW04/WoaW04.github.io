<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>关于lua以及luajit | The Blog of WoaW04</title><meta name="author" content="WoaW04"><meta name="copyright" content="WoaW04"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="学习一下lua及其相关知识 参考：https:&#x2F;&#x2F;wd-2711.tech&#x2F;2023&#x2F;08&#x2F;02&#x2F;about-lua&#x2F;#more 0x00 What is lualua简介Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。 嵌入式环境使用的脚本语言 lua采用的虚拟机根据指令获取操作数的方式不同，可以把虚">
<meta property="og:type" content="article">
<meta property="og:title" content="关于lua以及luajit">
<meta property="og:url" content="http://example.com/2024/01/15/lua/index.html">
<meta property="og:site_name" content="The Blog of WoaW04">
<meta property="og:description" content="学习一下lua及其相关知识 参考：https:&#x2F;&#x2F;wd-2711.tech&#x2F;2023&#x2F;08&#x2F;02&#x2F;about-lua&#x2F;#more 0x00 What is lualua简介Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。 嵌入式环境使用的脚本语言 lua采用的虚拟机根据指令获取操作数的方式不同，可以把虚">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WoaW04/Picture/image04CTF.png">
<meta property="article:published_time" content="2024-01-15T03:40:50.000Z">
<meta property="article:modified_time" content="2024-01-15T11:07:03.544Z">
<meta property="article:author" content="WoaW04">
<meta property="article:tag" content="RE">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/WoaW04/Picture/image04CTF.png"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/WoaW04/Picture/image04CTF.png"><link rel="canonical" href="http://example.com/2024/01/15/lua/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: false,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '关于lua以及luajit',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-15 19:07:03'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/WoaW04/Picture/image04CTF.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/WoaW04/Picture/image95796589_p0.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="The Blog of WoaW04"><img class="site-icon" src="https://cdn.jsdelivr.net/gh/WoaW04/Picture/image04CTF.png"/><span class="site-name">The Blog of WoaW04</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">关于lua以及luajit</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-15T03:40:50.000Z" title="发表于 2024-01-15 11:40:50">2024-01-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-15T11:07:03.544Z" title="更新于 2024-01-15 19:07:03">2024-01-15</time></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>学习一下lua及其相关知识</p>
<p>参考：<a target="_blank" rel="noopener" href="https://wd-2711.tech/2023/08/02/about-lua/#more">https://wd-2711.tech/2023/08/02/about-lua/#more</a></p>
<h2 id="0x00-What-is-lua"><a href="#0x00-What-is-lua" class="headerlink" title="0x00 What is lua"></a>0x00 What is lua</h2><h3 id="lua简介"><a href="#lua简介" class="headerlink" title="lua简介"></a>lua简介</h3><p>Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。</p>
<p>嵌入式环境使用的脚本语言</p>
<h3 id="lua采用的虚拟机"><a href="#lua采用的虚拟机" class="headerlink" title="lua采用的虚拟机"></a>lua采用的虚拟机</h3><p>根据指令获取操作数的方式不同，可以把虚拟机分为基于栈的虚拟机和基于寄存器的虚拟机。</p>
<p>JVM与python使用基于栈的虚拟机，该虚拟机是在当前栈中获取和保存操作数。例如：<code>a=b+c</code>，其相应指令为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push b</span><br><span class="line">push c</span><br><span class="line">add</span><br><span class="line">pop a</span><br></pre></td></tr></table></figure>

<p>其实现起来比较简单，每条指令占用的存储空间也小。但是，对于运算而言（例如加法），这需要4条指令才能完成，这会对效率有很大影响。</p>
<p>Lua目前采用基于寄存器的虚拟机，例如：<code>a=b+c</code>，其相应指令为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add a b c</span><br></pre></td></tr></table></figure>

<p>提高了效率。但是，每条指令占用的存储空间也增加了，在编译器设计上也增加了复杂度</p>
<h3 id="lua语言本身"><a href="#lua语言本身" class="headerlink" title="lua语言本身"></a>lua语言本身</h3><h4 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h4><p>Lua 是动态类型语言，变量不要类型定义,只需要为变量赋值。 值可以存储在变量中，作为参数传递或结果返回。</p>
<p>Lua有8种类型：nil、boolean、number、string、function、userdata、thread 和 table，他们都在<code>src/lua.h</code>中定义。</p>
<p>string对应<code>LUA_TSTRING</code></p>
<p>function对应<code>LUA_TFUNCTIOIN</code>。</p>
<p>而userdata比较特殊，它对应<code>LUA_TLIGHTUSERDATA</code> 和 <code>LUA_TUSERDATA</code>。</p>
<p><code>LUA_TLIGHTUSERDATA</code>是由 Lua 外部的使用者来完成，<code>LUA_TUSERDATA</code>则是通过 Lua 内部来完成，也就是说，<code>LUA_TLIGHTUSERDATA</code>是通过用户来维护其生命周期。</p>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">nil</td>
<td align="left">这个最简单，只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）。</td>
</tr>
<tr>
<td align="left">boolean</td>
<td align="left">包含两个值：false和true。</td>
</tr>
<tr>
<td align="left">number</td>
<td align="left">表示双精度类型的实浮点数</td>
</tr>
<tr>
<td align="left">string</td>
<td align="left">字符串由一对双引号或单引号来表示</td>
</tr>
<tr>
<td align="left">function</td>
<td align="left">由 C 或 Lua 编写的函数</td>
</tr>
<tr>
<td align="left">userdata</td>
<td align="left">表示任意存储在变量中的C数据结构</td>
</tr>
<tr>
<td align="left">thread</td>
<td align="left">表示执行的独立线路，用于执行协同程序</td>
</tr>
<tr>
<td align="left">table</td>
<td align="left">Lua 中的表（table）其实是一个”关联数组”（associative arrays），数组的索引可以是数字、字符串或表类型。在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表。</td>
</tr>
</tbody></table>
<p>Lua采用了标记清除式（Mark and Sweep）GC算法，算法简述： </p>
<p><strong>标记</strong>：每次执行GC时，先以若干根节点开始，逐个把直接或间接和它们相关的节点都做上标记； </p>
<p><strong>清除</strong>：当标记完成后，遍历整个对象链表，把被标记为需要删除的节点一一删除即可。</p>
<p>string、function、userdata、thread 和 table都需要gc。需要 gc 的数据类型，都会有一个 CommonHeader 成员。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lobject.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CommonHeader GCObject *next; lu_byte tt; lu_byte marked</span></span><br></pre></td></tr></table></figure>

<p>其中，<code>next</code>是指向下一个GC链表的成员，<code>tt</code>表示数据类型、<code>marked</code>为GC相关的标志位。</p>
<p>Lua的基本数据表示方式是type + union的方式，根据不同类型映射到union的不同结构上面, 统一的表示结构lua_TValue：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lua_TValue</span>&#123;</span></span><br><span class="line">    Value value_; 	<span class="comment">//实际存储的值</span></span><br><span class="line">    <span class="type">int</span> tt; 		<span class="comment">//存储当前数据类型</span></span><br><span class="line">&#125;TValue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">Value</span> &#123;</span></span><br><span class="line">  GCObject *gc;    <span class="comment">/* collectable objects */</span></span><br><span class="line">  <span class="type">void</span> *p;         <span class="comment">/* light userdata */</span></span><br><span class="line">  <span class="type">int</span> b;           <span class="comment">/* booleans */</span></span><br><span class="line">  lua_CFunction f; <span class="comment">/* light C functions */</span></span><br><span class="line">  lua_Integer i;   <span class="comment">/* integer numbers */</span></span><br><span class="line">  lua_Number n;    <span class="comment">/* float numbers */</span></span><br><span class="line">&#125; Value;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">GCObject</span>&#123;</span></span><br><span class="line">    GCheader gch;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">TString</span> <span class="title">ts</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">Udata</span> <span class="title">u</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">Closure</span> <span class="title">cl</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Table</span> <span class="title">h</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Proto</span> <span class="title">p</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">UpVal</span> <span class="title">uv</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lua_State</span> <span class="title">th</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，gc 表示需要垃圾回收的一些值，如 string、table 等；p 表示 light userdata，不会被 gc。</p>
<h5 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h5><p>Table是Lua中唯一表示数据结构的类型，他是一个混合数据结构。其中的函数环境 (env)、元表 (metatable)、模块 (module) 和注册表 (registery) 等都是通过 table 表示。Lua-5.0 后，table 包含一个哈希表部分和一个数组部分，哈希部分发生冲突就用链表解决。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Table</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> sizearray;</span><br><span class="line">  TValue *<span class="built_in">array</span>;</span><br><span class="line">  lu_byte lsizenode;</span><br><span class="line">  Node *node;</span><br><span class="line">  ...</span><br><span class="line">&#125; Table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  TValue i_val;</span><br><span class="line">  TKey i_key;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">TKey</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    TValuefields;</span><br><span class="line">    <span class="type">int</span> next;</span><br><span class="line">  &#125; nk;</span><br><span class="line">  TValue tvk;</span><br><span class="line">&#125; TKey;</span><br></pre></td></tr></table></figure>

<p>array、sizearray 用于表示数组部分及其大小，node、lsizenode 表示哈希部分与大小。</p>
<p>当查找table中的数据时，其逻辑如下：</p>
<p>（1）对于字符串类型，通过 <code>luaH_getstr()</code> 先获得相应字符串在哈希表中的链表，然后遍历这个链表，采用内存地址比较字符串，若找到则返回相应的值，否则 <code>nil</code> 。</p>
<p>（2）如果是整型，则调用 <code>luaH_getint()</code> 查找，如果 key 的值小于等于数组大小，则直接返回相应的值，否则去哈希表中去查找。</p>
<p>（3）对应其他类型，统一调用 <code>getgeneric()</code>，也就是计算 hash 值并在链表中查找，通过 <code>luaV_equalobj()</code> 对各种类型进行比较。</p>
<h4 id="lua解释器体系结构"><a href="#lua解释器体系结构" class="headerlink" title="lua解释器体系结构"></a>lua解释器体系结构</h4><p><img src="https://cdn.jsdelivr.net/gh/WoaW04/Picture/image202401151223157.png"></p>
<p>其中，stack 成员用于指向栈底，而 base 指向当前正在执行的函数的第一个参数，而 top 指向栈顶。寄存器实际上是栈上元素的别名。pc 来指向下一条要执行的指令。</p>
<h4 id="Lua字节码"><a href="#Lua字节码" class="headerlink" title="Lua字节码"></a>Lua字节码</h4><p>Lua 的指令使用 32bit 的无符号整型表示，可以通过<code>luac</code>编译成字节码。</p>
<p>例如，查看<code>lua5.1</code>编译后的字节码文件，文件头部12字节为：<code>1b4c 7561 5100 0104 0804 0800</code>。其中，<code>1b4c 7561</code>为<code>\033Lua</code>；<code>51</code>表示Lua版本为5.1；<code>00</code>为保留位；<code>01</code>表示字节序为小端；<code>04</code>表示int大小为4字节；<code>08</code>表示<code>size_t</code>的大小为8字节；<code>04</code>表示内部指令的大小为4字节；<code>08</code>代表lua中数字的大小为8字节。</p>
<h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><p>Lua虚拟机最后会调用<code>luaV_execute()</code>函数，其主要逻辑就是取指令、递增PC、根据指令操作码进行<code>switch...case...</code>。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>（1）Lua 语言本身是支持闭包（closure）的（把几个值和函数绑定在一起），在 Lua 中，这些值被称为 upvalues；而且，每个函数和一个函数环境（env）绑定。</p>
<p>（2）Lua编译系统的工作就是将符合语法规则的代码转换成可运行的闭包，闭包对象是 Lua 运行中一个函数的实例对象。</p>
<p>（3）每个闭包都对应着自己的 proto，而在运行期间，一个 proto 可以产生多个闭包来代表这个函数实例。</p>
<h3 id="lua中重要的API"><a href="#lua中重要的API" class="headerlink" title="lua中重要的API"></a>lua中重要的API</h3><h4 id="常用API函数"><a href="#常用API函数" class="headerlink" title="常用API函数"></a>常用API函数</h4><table>
<thead>
<tr>
<th align="left">API name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">void lua_pushcclosure (lua_State, lua_CFunction, int)</td>
<td align="left">注册C函数，fn为要注册的函数指针</td>
</tr>
<tr>
<td align="left">#define luaL_dofile (luaL_loadfile(L, filename) or lua_pcall(L, 0, LUA_MULTRET, 0))</td>
<td align="left">加载并运行指定的文件</td>
</tr>
<tr>
<td align="left">int luaL_loadfilex (lua_State, const char, const char)</td>
<td align="left">把文件加载为 Lua 代码，代码块的名字为name</td>
</tr>
<tr>
<td align="left">int lua_load (lua_State,lua_Reader,void,const char,const char)</td>
<td align="left">加载一段 Lua 代码块，但不运行它。 把一个编译好的代码块作为一个 Lua 函数压到栈顶。 否则，压入错误消息参数 reader 。 chunkname是一个字符串，标识了正在加载的块名。mode是一个字符串，指定如何编译数据块。可能取值为：（1）”b”：该块是预编译的二进制块。（2）”t”：预编译的文本块。</td>
</tr>
<tr>
<td align="left">const char *lua_pushfstring (lua_State, const char, …)</td>
<td align="left">把一个格式化的字符串压栈，然后返回这个字符串的指针，类似于sprintf</td>
</tr>
<tr>
<td align="left">const char *lua_tolstring (lua_State, int, size_t)</td>
<td align="left">将给定索引处的 Lua 值转换为一个 C 字符串，它还把字符串长度赋值到 *len中。</td>
</tr>
</tbody></table>
<h4 id="LuaU-undump函数"><a href="#LuaU-undump函数" class="headerlink" title="LuaU_undump函数"></a>LuaU_undump函数</h4><p>此函数用于lua文件头的检测。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">LClosure *<span class="title function_">luaU_undump</span><span class="params">(lua_State *L, ZIO *Z, <span class="type">const</span> <span class="type">char</span> *name)</span> &#123;</span><br><span class="line">    LoadState S;</span><br><span class="line">    ...</span><br><span class="line">    S.L = L;</span><br><span class="line">    S.Z = Z;</span><br><span class="line">    checkHeader(&amp;S);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_SIGNATURE <span class="string">&quot;\x1bLua&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUAC_FORMAT   0</span></span><br><span class="line"><span class="comment">// LUA_VERSION_MAJOR为主版本号，LUA_VERSION_MINOR为子版本号</span></span><br><span class="line"><span class="comment">// 例如Lua版本为5.3，则 LUAC_VERSION=83=0x53</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYINT(s)      (s[0]-<span class="string">&#x27;0&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUAC_VERSION  (MYINT(LUA_VERSION_MAJOR)*16+MYINT(LUA_VERSION_MINOR))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">checkHeader</span> <span class="params">(LoadState *S)</span> &#123;</span><br><span class="line">    checkliteral(S, LUA_SIGNATURE + <span class="number">1</span>, <span class="string">&quot;not a&quot;</span>);  <span class="comment">// 检查头部签名</span></span><br><span class="line">    <span class="keyword">if</span> (LoadByte(S) != LUAC_VERSION)              <span class="comment">// 检查luac版本号</span></span><br><span class="line">    	error(S, <span class="string">&quot;version mismatch in&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (LoadByte(S) != LUAC_FORMAT)               <span class="comment">// 检查格式号，一般为0</span></span><br><span class="line">    	error(S, <span class="string">&quot;format mismatch in&quot;</span>);</span><br><span class="line">    checkliteral(S, LUAC_DATA, <span class="string">&quot;corrupted&quot;</span>);      <span class="comment">// 检查头部的6-11字节</span></span><br><span class="line">    checksize(S, <span class="type">int</span>);                            <span class="comment">// 检查头部的12-16字节</span></span><br><span class="line">    checksize(S, <span class="type">size_t</span>);</span><br><span class="line">    checksize(S, Instruction);</span><br><span class="line">    checksize(S, lua_Integer);</span><br><span class="line">    checksize(S, lua_Number);</span><br><span class="line">    <span class="keyword">if</span> (LoadInteger(S) != LUAC_INT)</span><br><span class="line">    	error(S, <span class="string">&quot;endianness mismatch in&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (LoadNumber(S) != LUAC_NUM)</span><br><span class="line">    	error(S, <span class="string">&quot;float format mismatch in&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lua文件读取-解析的调用链示例"><a href="#Lua文件读取-解析的调用链示例" class="headerlink" title="Lua文件读取&amp;解析的调用链示例"></a>Lua文件读取&amp;解析的调用链示例</h3><p><img src="https://cdn.jsdelivr.net/gh/WoaW04/Picture/image202401151248129.png"></p>
<p>其中，<code>luaX_next</code>主要用于语法TOKEN的分割，而<code>statlist</code>主要根据分割出来的TOKEN，组装成语法块语句，最后将语句组装成语法树。</p>
<h2 id="0x01-luajit"><a href="#0x01-luajit" class="headerlink" title="0x01 luajit"></a>0x01 luajit</h2><p><code>Luajit</code>将原生Lua进行了扩展，使它支持JIT方式编译运行，<code>Luajit</code>有如下特点：</p>
<p>（1）运行时编译。</p>
<p>（2）兼容AOT编译。</p>
<p>（3）引入了中间表示IR。</p>
<h3 id="Luajit文件格式"><a href="#Luajit文件格式" class="headerlink" title="Luajit文件格式"></a>Luajit文件格式</h3><p>参考：<a target="_blank" rel="noopener" href="https://github.com/feicong/lua_re/blob/master/lua/lua_re3.md">https://github.com/feicong/lua_re/blob/master/lua/lua_re3.md</a></p>
<p>Luajit官方并没有直接给出<code>Luajit</code>字节码文件的格式文档，但可以通过阅读Luajit源码中加载与生成<code>Luajit</code>字节码文件的函数，来单步跟踪分析出它的文件格式，这两个函数分别是<code>lj_bcread()</code>与<code>lj_bcwrite()</code></p>
<p>从这两个函数调用的<code>bcread_header()</code>、<code>bcread_proto()</code>、<code>bcwrite_header()</code>、<code>bcwrite_proto()</code>等子函数名可以初步了解到，<code>Luajit</code>字节码文件与<code>Luac</code>一样，将文件格式分为头部分信息Header与函数信息Proto两部分。</p>
<p><code>Luajit</code>字节码文件的Header部分为了与<code>Luac</code>命名上保持一致，这里将其描述为<code>GlobalHeader</code>，它的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> signature[<span class="number">3</span>];</span><br><span class="line">    uchar version;</span><br><span class="line">    GlobalHeaderFlags flags;</span><br><span class="line">    <span class="keyword">if</span> (!is_stripped) &#123;</span><br><span class="line">        uleb128 length;</span><br><span class="line">        <span class="type">char</span> chunkname[uleb128_value(length)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; GlobalHeader;</span><br></pre></td></tr></table></figure>

<p>上述header解释如下：</p>
<p>（1）luajit字节码文件的头3个字节必须为<code>0x1b4c4a</code>，这是它的Magic Number（signature）。</p>
<p>（2）version是luajit字节码文件的版本号，占1个字节。</p>
<p>（3）flags是文件的标志位，采用uleb128编码（占用的字节码与数据的实际大小相关）。其中包含3个字段：</p>
<p>  （a）<code>FLAG_IS_BIG_ENDIAN</code>表示大端序还是小端序。</p>
<p>  （b）<code>FLAG_IS_STRIPPED</code>表示是否去除调试信息。如果包含调试信息，即<code>FLAG_IS_STRIPPED</code>没有被置位，那么在<code>GlobalHeader</code>中会多出两个字段：<code>length</code>（字符串长度），<code>chunkname</code>（Luajit文件的源文件名字符串）。</p>
<p>  （c）<code>FLAG_HAS_FFI</code>表示是否有外部函数接口（FFI信息）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    FLAG_IS_BIG_ENDIAN = <span class="number">0b00000001</span>,</span><br><span class="line">    FLAG_IS_STRIPPED = <span class="number">0b00000010</span>,</span><br><span class="line">    FLAG_HAS_FFI = <span class="number">0b00000100</span></span><br><span class="line">&#125; FLAG;</span><br></pre></td></tr></table></figure>

<p>Luajit字节码文件的<code>Proto</code>中有<code>ProtoHeader</code>字段，它描述了Proto的头部信息，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    uleb128 size;</span><br><span class="line">    <span class="keyword">if</span> (uleb128_value(size) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ProtoFlags flags;</span><br><span class="line">        uchar arguments_count;</span><br><span class="line">        uchar framesize;</span><br><span class="line">        uchar upvalues_count;</span><br><span class="line">        uleb128 complex_constants_count;</span><br><span class="line">        uleb128 numeric_constants_count;</span><br><span class="line">        uleb128 instructions_count;</span><br><span class="line">        <span class="keyword">if</span> (!is_stripped) &#123;</span><br><span class="line">            uleb128 debuginfo_size;</span><br><span class="line">            uleb128 first_line_number;</span><br><span class="line">            uleb128 lines_count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ProtoHeader;</span><br></pre></td></tr></table></figure>

<p>上述<code>ProtoHeader</code>解释如下：</p>
<p>（1）<code>size</code>字段是标识了从当前字段开始，整个<code>Proto</code>结构体的大小。</p>
<p>（2）<code>flas</code>是<code>ProtoHeader</code>的标志位，其使用的<code>ProtoFlags</code>是一个uchar类型，取值如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef enum &#123;</span><br><span class="line">    FLAG_HAS_CHILD = 0b00000001,</span><br><span class="line">    FLAG_IS_VARIADIC = 0b00000010,</span><br><span class="line">    FLAG_HAS_FFI = 0b00000100,</span><br><span class="line">    FLAG_JIT_DISABLED = 0b00001000,</span><br><span class="line">    FLAG_HAS_ILOOP = 0b00010000</span><br><span class="line">&#125; PROTO_FLAG;</span><br></pre></td></tr></table></figure>

<p>​		各取值的含义如下：</p>
<p>  （a）<code>FLAG_HAS_CHILD</code>标识当前<code>proto</code>是一个子函数，也就是闭包（closure）。举个例子来理解一下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Create</span><span class="params">(n)</span></span> </span><br><span class="line">	<span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">foo1</span><span class="params">()</span></span></span><br><span class="line">		<span class="built_in">print</span>(n)</span><br><span class="line">        <span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">foo2</span><span class="params">()</span></span></span><br><span class="line">            n = n + <span class="number">10</span> </span><br><span class="line">		    <span class="built_in">print</span>(n)</span><br><span class="line">            <span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">foo3</span><span class="params">()</span></span></span><br><span class="line">                n = n + <span class="number">100</span></span><br><span class="line">                <span class="built_in">print</span>(n)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">return</span> foo1,foo2,foo3</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">f1,f2,f3 = Create(<span class="number">1000</span>)</span><br><span class="line">f1()</span><br></pre></td></tr></table></figure>

<p>上述代码中，最外层的<code>Create()</code>向内，每个function都包含一个<code>Closure</code>。在Luac文件格式中，每个<code>Proto</code>都有一个<code>Protos</code>字段，它用来描述<code>Proto</code>与<code>Closure</code>之间的层次信息，<code>Proto</code>采用从外向内的递归方式进行存储。而<code>LUAJIT</code>则采用线性的从内向外的同级结构进行存储，<code>PROTO</code>与<code>CLOSURE</code>之前的层级关系使用<code>FLAGS</code>字段的<code>FLAG_HAS_CHILD</code>标志位进行标识，当<code>FLAGS</code>字段的<code>FLAG_HAS_CHILD</code>标志位被置位，则表示当前层的<code>PROTO</code>是上一层<code>PROTO</code>的<code>CLOSURE</code>。上述代码在Luajit的文件结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Luajit</span> <span class="title">lj</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">GlobalHeader</span> <span class="title">header</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Proto</span> <span class="title">proto</span>[0];</span>  <span class="comment">//foo3()</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Proto</span> <span class="title">proto</span>[1];</span>  <span class="comment">//foo2()</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Proto</span> <span class="title">proto</span>[2];</span>  <span class="comment">//foo1()</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Proto</span> <span class="title">proto</span>[3];</span>  <span class="comment">//Create()</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Proto</span> <span class="title">proto</span>[4];</span>  <span class="comment">//Full file</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Proto</span> <span class="title">proto</span>[5];</span>  <span class="comment">//empty</span></span><br></pre></td></tr></table></figure>

<p>从存局中可以看出，最内层的<code>foo3()</code>位于<code>Proto</code>的最外层，它与<code>LUAC</code>的布局是相反的，而<code>proto[4]</code>表示了整个Lua文件，它是<code>Proto</code>的最上层。最后的<code>proto[5]</code>，它在读取其<code>ProtoHeader</code>的<code>size</code>字段时，由于其值为0，而中止了整个文件的解析。即它的内容为空。</p>
<p>  （b）<code>FLAG_IS_VARIADIC</code>标识了当前<code>Proto</code>是否返回多个值，上面的代码中，只有<code>Create()</code>的<code>flags</code>字段会对该标志置位（因为只有它有返回值）。</p>
<p>  （c）<code>FLAG_HAS_FFI</code>标识当前<code>Proto</code>是否有通过FFI扩展调用系统的功能函数。</p>
<p>  （d）<code>FLAG_JIT_DISABLED</code>标识当前<code>Proto</code>是否禁用JIT，对于包含了具体代码的<code>Proto</code>，它的值通常没有没有被置位，表示有JIT代码。</p>
<p>  （e）<code>FLAG_HAS_ILOOP</code>标识了当前<code>Proto</code>是否包含了<code>ILOOP</code>与<code>JLOOP</code>等指令，编译器好进行优化。</p>
<p>（3）<code>arguments_count</code>表示当前<code>Proto</code>有几个参数。</p>
<p>（4）<code>framesize</code>标识了<code>Proto</code>使用的栈大小。</p>
<p>（5）<code>upvalues_count</code>、<code>complex_constants_count</code>、<code>numeric_constants_count</code>、<code>instructions_count</code>分别表示UpValue个数、复合常数个数、数值常数个数、指令条数等信息。</p>
<p> UpValue：当一个函数引用了一个外部函数的局部变量时，这个局部变量就成为了 Upvalue。Upvalue 会在堆上被创建并持续存活，直到没有任何函数引用它为止。当一个函数被垃圾回收时，它所引用的 Upvalue 也会被垃圾回收。</p>
<p>（6）如果包含调试信息，那么会有<code>debuginfo_size</code>、<code>first_line_number</code>、<code>lines_count</code>，分别表示<code>DebugInfo</code>结构体占用的字节大小、当前<code>Proto</code>在源文件中的起始行、当前<code>Proto</code>在源文件中所占的行数。</p>
<p> 下面就到了proto的主体部分：</p>
<p>（1）指令<code>Instruction</code>数组，每条指令长度与<code>Luac</code>一样，占用32位，但使用的指令格式完全不同。</p>
<p>（2）常量信息，主要包含3个数组，分别是<code>upvalues</code>、<code>complex_constants</code>、<code>numeric_constants</code>数组。<code>complex_constants</code>可以保存字符串、整型、浮点型、TAB表等信息。</p>
<p>（3）<code>debuginfo</code>调试信息。分为<code>LineInfo</code>与<code>VarInfos</code>两部分，前者是存储的一条条的行信息，后者是局部变量信息，包括变量类型、名称、以及它的作用域起始地址与结束地址。</p>
<h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><p><code>Luajit</code>的线性结构解析起来比<code>Luac</code>简单，只需要按序解析<code>Proto</code>，直接读取到字节0结束即可。</p>
<h2 id="0x02-Luajit字节码"><a href="#0x02-Luajit字节码" class="headerlink" title="0x02 Luajit字节码"></a>0x02 Luajit字节码</h2><p>Luajit的字节码设计与原生Lua有很多不同，最终到的效果是：字节码的编码实现更加简单，执行效率也比原生LUAC指令更加高效。</p>
<p>Lua指令的参考文档为：<a target="_blank" rel="noopener" href="http://wiki.luajit.org/Bytecode-2.0">http://wiki.luajit.org/Bytecode-2.0</a></p>
<p>每条指令都为32位，指令分为opcode与操作数两部分。Lua原生指令是不对齐的，即不同的域（A、B、C等）不一定为8位或16位，而Luajit的每个域都为8位或16位。</p>
<p>Luajit的指令由5部分组成，分别为：指令名称name、3个操作数域ma&#x2F;mb&#x2F;mc、指令类型mt。</p>
<p>指令名称例如：ISLT、ADDVV、USETS、TGETV。它们有些有前后缀，后缀有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">V variable slot。变量槽。</span><br><span class="line">S string constant。字符串常量。</span><br><span class="line">N number constant。数值常量。</span><br><span class="line">P primitive type。原始类型。</span><br><span class="line">B unsigned byte literal。无符号字节字面量。</span><br><span class="line">M multiple arguments/results。多参数与返回值。</span><br></pre></td></tr></table></figure>

<p>前缀有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T table。表。</span><br><span class="line">F function。函数。</span><br><span class="line">U UpValue。上值。</span><br><span class="line">K constant。常量。</span><br><span class="line">G global。全局。</span><br></pre></td></tr></table></figure>

<p>那么，USETS代表为UpValue设置字符串值，TGETV代表获取一个表结构中指定索引的数据。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">WoaW04</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/01/15/lua/">http://example.com/2024/01/15/lua/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">The Blog of WoaW04</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/RE/">RE</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/WoaW04/Picture/image04CTF.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/01/23/2023%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2ezlua/" title="2023巅峰极客ezlua"><img class="cover" src="https://cdn.jsdelivr.net/gh/WoaW04/Picture/image202401151142821.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">2023巅峰极客ezlua</div></div></a></div><div class="next-post pull-right"><a href="/2024/01/14/2023%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2m1-read/" title="2023巅峰极客m1_read"><img class="cover" src="https://cdn.jsdelivr.net/gh/WoaW04/Picture/image%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-14%20120400.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">2023巅峰极客m1_read</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/WoaW04/Picture/image04CTF.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">WoaW04</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/WoaW04"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x00-What-is-lua"><span class="toc-number">1.</span> <span class="toc-text">0x00 What is lua</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#lua%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">lua简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lua%E9%87%87%E7%94%A8%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">1.2.</span> <span class="toc-text">lua采用的虚拟机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lua%E8%AF%AD%E8%A8%80%E6%9C%AC%E8%BA%AB"><span class="toc-number">1.3.</span> <span class="toc-text">lua语言本身</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">类型定义</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Table"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">Table</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lua%E8%A7%A3%E9%87%8A%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.2.</span> <span class="toc-text">lua解释器体系结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lua%E5%AD%97%E8%8A%82%E7%A0%81"><span class="toc-number">1.3.3.</span> <span class="toc-text">Lua字节码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.3.4.</span> <span class="toc-text">执行流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">1.3.5.</span> <span class="toc-text">其他</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lua%E4%B8%AD%E9%87%8D%E8%A6%81%E7%9A%84API"><span class="toc-number">1.4.</span> <span class="toc-text">lua中重要的API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8API%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.1.</span> <span class="toc-text">常用API函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LuaU-undump%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.2.</span> <span class="toc-text">LuaU_undump函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lua%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96-%E8%A7%A3%E6%9E%90%E7%9A%84%E8%B0%83%E7%94%A8%E9%93%BE%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.5.</span> <span class="toc-text">Lua文件读取&amp;解析的调用链示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x01-luajit"><span class="toc-number">2.</span> <span class="toc-text">0x01 luajit</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Luajit%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.1.</span> <span class="toc-text">Luajit文件格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96-1"><span class="toc-number">2.2.</span> <span class="toc-text">其他</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x02-Luajit%E5%AD%97%E8%8A%82%E7%A0%81"><span class="toc-number">3.</span> <span class="toc-text">0x02 Luajit字节码</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background: #FFFFFF00"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By WoaW04</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div></div></body></html>